<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ES6中Reflect对象与Proxy结合实现代理和响应式编程"><meta name="keywords" content="JavaScript,Web,ES6"><meta name="author" content="Sir_Liu"><meta name="copyright" content="Sir_Liu"><title>ES6中Reflect对象与Proxy结合实现代理和响应式编程 | Coding Your Life</title><link rel="shortcut icon" href="/vite.svg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Site Name Atom Feed"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4583227810964573" crossorigin="anonymous"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '3.9.0'
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代理对象"><span class="toc-number">2.</span> <span class="toc-text">代理对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础数据类型的代理"><span class="toc-number">2.0.1.</span> <span class="toc-text">基础数据类型的代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂数据类型的代理"><span class="toc-number">2.0.2.</span> <span class="toc-text">复杂数据类型的代理</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#响应式编程"><span class="toc-number">3.</span> <span class="toc-text">响应式编程</span></a></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/mirror-assets/16d2a30b4d8e2a895e6~tplv-t2oaga2asx-jj-mark:72:72:0:0:q75.avis"></div><div class="author-info__name text-center">Sir_Liu</div><div class="author-info__description text-center">无论从事什么行业，只要做好两件事就够了，一个是你的专业、一个是你的人品，专业决定了你的存在，人品决定了你的人脉，剩下的就是坚持，用善良專業和真诚赢取更多的信任。（No matter what industry you are in, it is enough to do two things well, one is your profession and the other is your character. Your profession determines your existence, and your character determines your network. The rest is persistence, and you should win more trust with kindness, professionalism and sincerity.）</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(chrome-extension://pkfjcehoipcdbiilobhcblbkmelocaka/start/skin/images/bg-51.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coding Your Life</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/atom.xml">rss</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">ES6中Reflect对象与Proxy结合实现代理和响应式编程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2025-05-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1k</span><span class="post-meta__separator">|</span><span>阅读时长: 4 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 JavaScript 中，<strong><code>Reflect</code></strong> 是一个内置对象，提供了拦截和操作 JavaScript 对象的元方法。它是 ES6 (ES2015) 引入的特性，主要用于简化元编程（meta-programming）并与 <strong>Proxy</strong> 结合使用实现对对象属性更细粒度的操作控制。</p>
<h1 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h1><p><strong>Proxy</strong> 的第一个参数为要进行代理的目标对象，类型为Object，如果我们代理的目标是一个基础数据类型那应该怎么实现呢？</p>
<h3 id="基础数据类型的代理"><a href="#基础数据类型的代理" class="headerlink" title="基础数据类型的代理"></a>基础数据类型的代理</h3><p>在 JavaScript 中，<strong>基础数据类型（如 <code>number</code>、<code>string</code>、<code>boolean</code> 等）无法直接被 <code>Proxy</code> 代理</strong>，因为 <code>Proxy</code> 只能拦截对象（包括数组、函数、类等）的操作。但可以通过对象封装的方式间接代理基础类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target  = &#123;</span><br><span class="line">    value: <span class="string">'123'</span> <span class="comment">// 这里可以是number 、string、boolean...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key, receiver)&#123;</span><br><span class="line">        <span class="comment">// receiver 指向 proxy实例</span></span><br><span class="line">        <span class="comment">// 思考 ？ 此处可否直接返回 target[key]</span></span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> (target, key, value, receiver)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上述代码中有一个疑问，能否通过<code>return target[key]</code> 取代 <code>return Reflect.get(target, key, receiver)</code>? 事实上这里<code>target[key] 等价于 Reflect.get(target, key)</code>, <code>receiver</code>是指向代理的实例，相当于<code>call/apply</code>的第一个参数，用于指定函数执行的上下文,上面例子中如果不涉及this指向，仅仅是对于简单类型的代理可使用<code>Reflect.get(target, key) 或 target[key]（但不推荐）</code>，接下来我们看下面这个例子说明不推荐的原因：</p>
<h3 id="复杂数据类型的代理"><a href="#复杂数据类型的代理" class="headerlink" title="复杂数据类型的代理"></a>复杂数据类型的代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people  = &#123;</span><br><span class="line">    <span class="keyword">get</span> name()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'thisArg:'</span>, <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    _name:<span class="string">'xixi'</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(people, &#123;</span><br><span class="line">     <span class="keyword">get</span> (target, key, receiver)&#123;</span><br><span class="line">      <span class="comment">// 思考 ？ 此处可否直接返回 target[key]</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get name:'</span>, target, receiver)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">     &#125;,</span><br><span class="line">     </span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(proxy1.name)</span><br><span class="line"> <span class="comment">// 输出：</span></span><br><span class="line"> <span class="comment">// get name: &#123; name: [Getter], _name: 'xixi' &#125; name &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// thisArg: &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// get name: &#123; name: [Getter], _name: 'xixi' &#125; _name &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// xixi</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> proxy2 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(people, &#123;</span><br><span class="line">     <span class="keyword">get</span> (target, key, receiver)&#123;</span><br><span class="line">      <span class="comment">// 思考 ？ 此处可否直接返回 target[key]</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get name:'</span>, target, receiver)</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">     &#125;,</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(proxy2.name)</span><br><span class="line"> <span class="comment">// 输出：</span></span><br><span class="line"> <span class="comment">// get name: &#123; name: [Getter], _name: 'xixi' &#125; name &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// thisArg: &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// xixi</span></span><br></pre></td></tr></table></figure>
<p>结论：通过对比输出结果，可以看出直接<code>return target[key]</code>会导致<code>this</code>无法绑定在代理对象上，当修改属性时代理事件就无法触发导致错误，所以建议直接按照<code>Reflect.get(target, key, receiver)</code>处理。</p>
<h1 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h1><p>此处我们以<code>vue3</code>的响应式编程为例，自定义实现ref和reactive的简化版:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 存储依赖关系的 WeakMap</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在收集依赖的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 副作用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  activeEffect = fn;</span><br><span class="line">  fn(); <span class="comment">// 执行副作用，触发依赖收集</span></span><br><span class="line">  activeEffect = <span class="literal">null</span>; <span class="comment">// 清空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖收集函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dep.add(activeEffect); <span class="comment">// 将副作用添加到依赖集合</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发依赖更新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> dep = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">    dep.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> effect()); <span class="comment">// 执行所有依赖副作用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版 reactive</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key, receiver) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      track(target, key); <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      <span class="keyword">if</span> (oldValue !== value) &#123;</span><br><span class="line">        trigger(target, key); <span class="comment">// 触发更新</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版 ref</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _value = &#123; <span class="attr">value</span>: initialValue &#125;; <span class="comment">// 创建一个包裹对象</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对于对象类型，使用 reactive 转换为响应式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialValue === <span class="string">'object'</span> &amp;&amp; initialValue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    _value.value = reactive(initialValue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(_value, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">      track(target, key); <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">      <span class="comment">// 对于对象类型，使用 reactive 转换</span></span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'value'</span> &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">        target[key] = reactive(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">      trigger(target, key); <span class="comment">// 触发更新</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Sir_Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gofugui.github.io/2025/05/21/ES6中Reflect对象与Proxy结合实现代理和响应式编程/">https://gofugui.github.io/2025/05/21/ES6中Reflect对象与Proxy结合实现代理和响应式编程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gofugui.github.io">Coding Your Life</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/Web/">Web</a><a class="post-meta__tags" href="/tags/ES6/">ES6</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2025/05/22/vue3 和 react 虚拟dom/"><i class="fa fa-chevron-left">  </i><span>vue3 和 react 虚拟dom</span></a></div><div class="next-post pull-right"><a href="/2024/07/27/使用MediaRecord实现运动相机功能 copy/"><span>前端技术分享MediaRecord实现运动相机</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'Ov23liqBpY9MxdjqDFTA',
  clientSecret: 'c824e3fe864528851e7734e9f4661a8fd108b390',
  repo: 'gofugui.github.io',
  owner: 'gofugui',
  admin: 'gofugui',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4583227810964573" data-ad-slot="8925032663" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});
</script><footer class="footer-bg" style="background-image: url(chrome-extension://pkfjcehoipcdbiilobhcblbkmelocaka/start/skin/images/bg-51.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By Sir_Liu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script> <script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>