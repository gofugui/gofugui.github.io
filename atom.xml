<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding Your Life</title>
  
  <subtitle>技术与日常分享 &amp; Technology and daily sharing &amp; テクノロジーと日々の共有</subtitle>
  <link href="https://gofugui.github.io/atom.xml" rel="self"/>
  
  <link href="https://gofugui.github.io/"/>
  <updated>2025-05-22T14:23:36.693Z</updated>
  <id>https://gofugui.github.io/</id>
  
  <author>
    <name>Sir_Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue3 和 react 虚拟dom</title>
    <link href="https://gofugui.github.io/2025/05/22/vue3%20%E5%92%8C%20react%20%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://gofugui.github.io/2025/05/22/vue3%20%E5%92%8C%20react%20%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2025-05-21T16:00:00.000Z</published>
    <updated>2025-05-22T14:23:36.693Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 3 和 React 的虚拟 DOM 在核心概念上类似，但在实现细节、优化策略和使用方式上存在显著差异。以下是两者的关键对比：</p><h3 id="一、核心实现差异"><a href="#一、核心实现差异" class="headerlink" title="一、核心实现差异"></a><strong>一、核心实现差异</strong></h3><h4 id="1-Diff-算法"><a href="#1-Diff-算法" class="headerlink" title="1. Diff 算法"></a>1. <strong>Diff 算法</strong></h4><ul><li><p><strong>Vue 3</strong>：</p><ul><li>使用 <strong>预处理 + 最长递增子序列（LIS</strong> 算法，时间复杂度为 <strong>O(n log n)</strong></li><li>优先处理相同前置 / 后置元素，快速跳过无需比较的节点</li><li>通过<code>ShapeFlag</code>位运算快速判断节点类型</li></ul></li><li><p><strong>React</strong>：</p><ul><li>使用<strong>双指针遍历 + key 比较</strong>，默认时间复杂度为 <strong>O(n)</strong></li><li>依赖<code>key</code>属性识别同层节点变化</li><li>2020 年后引入<strong>Fiber 架构</strong>，将渲染任务拆分为小单元（可中断）</li></ul></li></ul><p>javascript<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">// Vue 3的Diff算法（简化）</span><br><span class="line">// 1. 预处理相同前置/后置节点</span><br><span class="line">// 2. 处理新增/删除节点</span><br><span class="line">// 3. 使用LIS算法计算最小移动次数</span><br><span class="line">function patchKeyedChildren(c1, c2, container, parentAnchor) &#123;</span><br><span class="line">  let i = 0;</span><br><span class="line">  const l1 = c1.length;</span><br><span class="line">  const l2 = c2.length;</span><br><span class="line">  let e1 = l1 - 1; // 旧节点的结束索引</span><br><span class="line">  let e2 = l2 - 1; // 新节点的结束索引</span><br><span class="line"></span><br><span class="line">  // 1. 预处理相同前置节点</span><br><span class="line">  // (a b) c</span><br><span class="line">  // (a b) d e</span><br><span class="line">  while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    const n1 = c1[i];</span><br><span class="line">    const n2 = c2[i];</span><br><span class="line">    if (isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">      patch(n1, n2, container);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 2. 预处理相同后置节点</span><br><span class="line">  // a (b c)</span><br><span class="line">  // d e (b c)</span><br><span class="line">  while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    const n1 = c1[e1];</span><br><span class="line">    const n2 = c2[e2];</span><br><span class="line">    if (isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">      patch(n1, n2, container);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    e1--;</span><br><span class="line">    e2--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 3. 处理新增节点（旧节点已遍历完，新节点有剩余）</span><br><span class="line">  // (a b)</span><br><span class="line">  // (a b) c d</span><br><span class="line">  // i = 2, e1 = 1, e2 = 3</span><br><span class="line">  if (i &gt; e1) &#123;</span><br><span class="line">    if (i &lt;= e2) &#123;</span><br><span class="line">      const nextPos = e2 + 1;</span><br><span class="line">      const anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor;</span><br><span class="line">      while (i &lt;= e2) &#123;</span><br><span class="line">        patch(null, c2[i], container, anchor);</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 4. 处理删除节点（新节点已遍历完，旧节点有剩余）</span><br><span class="line">  // (a b) c d</span><br><span class="line">  // (a b)</span><br><span class="line">  // i = 2, e1 = 3, e2 = 1</span><br><span class="line">  else if (i &gt; e2) &#123;</span><br><span class="line">    while (i &lt;= e1) &#123;</span><br><span class="line">      unmount(c1[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 5. 处理乱序节点（核心Diff）</span><br><span class="line">  // a b [c d e] f g</span><br><span class="line">  // a b [e d c h] f g</span><br><span class="line">  else &#123;</span><br><span class="line">    const s1 = i; // 旧节点的开始索引</span><br><span class="line">    const s2 = i; // 新节点的开始索引</span><br><span class="line"></span><br><span class="line">    // 5.1 建立新节点的key到index的映射</span><br><span class="line">    const keyToNewIndexMap = new Map();</span><br><span class="line">    for (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">      const nextChild = c2[i];</span><br><span class="line">      if (nextChild.key !== null) &#123;</span><br><span class="line">        keyToNewIndexMap.set(nextChild.key, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.2 遍历旧节点，寻找匹配的新节点</span><br><span class="line">    let j;</span><br><span class="line">    let patched = 0;</span><br><span class="line">    const toBePatched = e2 - s2 + 1;</span><br><span class="line">    let moved = false;</span><br><span class="line">    let maxNewIndexSoFar = 0;</span><br><span class="line">    const newIndexToOldIndexMap = new Array(toBePatched).fill(0);</span><br><span class="line"></span><br><span class="line">    for (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">      const prevChild = c1[i];</span><br><span class="line">      if (patched &gt;= toBePatched) &#123;</span><br><span class="line">        // 所有新节点都已处理，剩余旧节点全部删除</span><br><span class="line">        unmount(prevChild);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let newIndex;</span><br><span class="line">      if (prevChild.key !== null) &#123;</span><br><span class="line">        // 通过key查找新节点位置</span><br><span class="line">        newIndex = keyToNewIndexMap.get(prevChild.key);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 没有key，遍历查找</span><br><span class="line">        for (j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">          if (</span><br><span class="line">            newIndexToOldIndexMap[j - s2] === 0 &amp;&amp;</span><br><span class="line">            isSameVNodeType(prevChild, c2[j])</span><br><span class="line">          ) &#123;</span><br><span class="line">            newIndex = j;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (newIndex === undefined) &#123;</span><br><span class="line">        // 没有找到匹配的新节点，删除当前旧节点</span><br><span class="line">        unmount(prevChild);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 保存旧节点索引（+1 是为了避免与默认值0冲突）</span><br><span class="line">        newIndexToOldIndexMap[newIndex - s2] = i + 1;</span><br><span class="line">        </span><br><span class="line">        // 判断节点是否需要移动</span><br><span class="line">        if (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">          maxNewIndexSoFar = newIndex;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          moved = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 复用旧节点，更新内容</span><br><span class="line">        patch(prevChild, c2[newIndex], container);</span><br><span class="line">        patched++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5.3 使用LIS算法计算最小移动次数</span><br><span class="line">    const increasingNewIndexSequence = moved</span><br><span class="line">      ? getSequence(newIndexToOldIndexMap)</span><br><span class="line">      : [];</span><br><span class="line">    j = increasingNewIndexSequence.length - 1;</span><br><span class="line"></span><br><span class="line">    // 5.4 移动和插入节点</span><br><span class="line">    for (i = toBePatched - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">      const nextIndex = s2 + i;</span><br><span class="line">      const nextChild = c2[nextIndex];</span><br><span class="line">      const anchor = nextIndex + 1 &lt; l2 ? c2[nextIndex + 1].el : parentAnchor;</span><br><span class="line"></span><br><span class="line">      if (newIndexToOldIndexMap[i] === 0) &#123;</span><br><span class="line">        // 新节点，需要插入</span><br><span class="line">        patch(null, nextChild, container, anchor);</span><br><span class="line">      &#125; else if (moved) &#123;</span><br><span class="line">        // 需要移动节点</span><br><span class="line">        if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">          move(nextChild, container, anchor);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          j--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断两个VNode是否可以复用（key和type都相同）</span><br><span class="line">function isSameVNodeType(n1, n2) &#123;</span><br><span class="line">  return n1.type === n2.type &amp;&amp; n1.key === n2.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最长递增子序列算法（Vue 3源码实现）</span><br><span class="line">function getSequence(arr) &#123;</span><br><span class="line">  const p = arr.slice();</span><br><span class="line">  const result = [0];</span><br><span class="line">  let i, j, u, v, c;</span><br><span class="line">  const len = arr.length;</span><br><span class="line">  for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    const arrI = arr[i];</span><br><span class="line">    if (arrI !== 0) &#123;</span><br><span class="line">      j = result[result.length - 1];</span><br><span class="line">      if (arr[j] &lt; arrI) &#123;</span><br><span class="line">        p[i] = j;</span><br><span class="line">        result.push(i);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      u = 0;</span><br><span class="line">      v = result.length - 1;</span><br><span class="line">      while (u &lt; v) &#123;</span><br><span class="line">        c = (u + v) &gt;&gt; 1;</span><br><span class="line">        if (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">          u = c + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          v = c;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">        if (u &gt; 0) &#123;</span><br><span class="line">          p[i] = result[u - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        result[u] = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  u = result.length;</span><br><span class="line">  v = result[u - 1];</span><br><span class="line">  while (u-- &gt; 0) &#123;</span><br><span class="line">    result[u] = v;</span><br><span class="line">    v = p[v];</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">// React的Diff算法（简化）</span><br><span class="line">// 1. 双指针遍历新旧children</span><br><span class="line">// 2. 根据key判断节点是更新、新增还是删除</span><br><span class="line">function reconcileChildren(current, workInProgress) &#123;</span><br><span class="line">  // 当前渲染的fiber节点</span><br><span class="line">  const currentFirstChild = current.child;</span><br><span class="line">  // 工作中的fiber节点（新的虚拟DOM）</span><br><span class="line">  let workInProgressChild = workInProgress.child;</span><br><span class="line">  </span><br><span class="line">  // 1. 双指针初始化</span><br><span class="line">  let oldFiber = currentFirstChild;</span><br><span class="line">  let newIdx = 0;</span><br><span class="line">  let prevNewFiber = null;</span><br><span class="line">  </span><br><span class="line">  // 2. 第一轮遍历：处理相同位置的节点（快速路径）</span><br><span class="line">  while (oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length) &#123;</span><br><span class="line">    const newChild = newChildren[newIdx];</span><br><span class="line">    </span><br><span class="line">    // 2.1 通过key和type判断节点是否可以复用</span><br><span class="line">    const sameType = oldFiber.type === newChild.type;</span><br><span class="line">    </span><br><span class="line">    if (!sameType) &#123;</span><br><span class="line">      // 2.2 类型不同，无法复用，标记旧节点为删除</span><br><span class="line">      if (oldFiber) &#123;</span><br><span class="line">        deleteChild(workInProgress, oldFiber);</span><br><span class="line">      &#125;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2.3 可以复用，创建新的fiber节点</span><br><span class="line">    const newFiber = createWorkInProgress(oldFiber, newChild.props);</span><br><span class="line">    </span><br><span class="line">    // 2.4 连接到DOM树</span><br><span class="line">    if (prevNewFiber === null) &#123;</span><br><span class="line">      workInProgressChild = newFiber;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      prevNewFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    prevNewFiber = newFiber;</span><br><span class="line">    </span><br><span class="line">    // 2.5 移动指针</span><br><span class="line">    oldFiber = oldFiber.sibling;</span><br><span class="line">    newIdx++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 3. 处理新增节点（旧列表已遍历完，新列表还有剩余）</span><br><span class="line">  if (oldFiber === null) &#123;</span><br><span class="line">    while (newIdx &lt; newChildren.length) &#123;</span><br><span class="line">      const newChild = newChildren[newIdx];</span><br><span class="line">      const newFiber = createFiberFromElement(newChild);</span><br><span class="line">      </span><br><span class="line">      if (prevNewFiber === null) &#123;</span><br><span class="line">        workInProgressChild = newFiber;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        prevNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      prevNewFiber = newFiber;</span><br><span class="line">      newIdx++;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 4. 处理删除节点（新列表已遍历完，旧列表还有剩余）</span><br><span class="line">  if (newIdx === newChildren.length) &#123;</span><br><span class="line">    while (oldFiber !== null) &#123;</span><br><span class="line">      deleteChild(workInProgress, oldFiber);</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 5. 复杂情况：乱序节点处理（使用key进行重排序）</span><br><span class="line">  // 5.1 建立旧节点的key到index的映射</span><br><span class="line">  const existingChildren = mapRemainingChildren(oldFiber);</span><br><span class="line">  </span><br><span class="line">  // 5.2 遍历剩余新节点，寻找最佳匹配</span><br><span class="line">  for (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    const newChild = newChildren[newIdx];</span><br><span class="line">    </span><br><span class="line">    // 5.3 通过key查找可复用的旧节点</span><br><span class="line">    const matchedFiber = existingChildren.get(</span><br><span class="line">      newChild.key === null ? newChild.type : newChild.key</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    if (matchedFiber) &#123;</span><br><span class="line">      // 5.4 复用找到的节点</span><br><span class="line">      const newFiber = useFiber(matchedFiber, newChild.props);</span><br><span class="line">      // 从映射中删除已复用的节点</span><br><span class="line">      existingChildren.delete(</span><br><span class="line">        newChild.key === null ? newChild.type : newChild.key</span><br><span class="line">      );</span><br><span class="line">      </span><br><span class="line">      // 连接到DOM树</span><br><span class="line">      if (prevNewFiber === null) &#123;</span><br><span class="line">        workInProgressChild = newFiber;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        prevNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      prevNewFiber = newFiber;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 5.5 没有可复用的节点，创建新节点</span><br><span class="line">      const newFiber = createFiberFromElement(newChild);</span><br><span class="line">      </span><br><span class="line">      if (prevNewFiber === null) &#123;</span><br><span class="line">        workInProgressChild = newFiber;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        prevNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      prevNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 5.6 删除所有未被复用的旧节点</span><br><span class="line">  existingChildren.forEach(child =&gt; deleteChild(workInProgress, child));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辅助函数：建立旧节点的key到fiber的映射</span><br><span class="line">function mapRemainingChildren(currentFirstChild) &#123;</span><br><span class="line">  const existingChildren = new Map();</span><br><span class="line">  let existingChild = currentFirstChild;</span><br><span class="line">  </span><br><span class="line">  while (existingChild !== null) &#123;</span><br><span class="line">    if (existingChild.key !== null) &#123;</span><br><span class="line">      existingChildren.set(existingChild.key, existingChild);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      existingChildren.set(existingChild.type, existingChild);</span><br><span class="line">    &#125;</span><br><span class="line">    existingChild = existingChild.sibling;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return existingChildren;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-渲染优化"><a href="#2-渲染优化" class="headerlink" title="2. 渲染优化"></a>2. <strong>渲染优化</strong></h4><ul><li><p><strong>Vue 3</strong>：</p><ul><li><strong>编译时优化</strong>：静态提升（Static Hoisting）、Block Tree</li><li>自动标记动态节点，减少 Diff 范围</li><li>事件处理函数缓存（<code>cacheHandlers</code>）</li></ul></li><li><p><strong>React</strong>：</p><ul><li><strong>运行时优化</strong>：依赖<code>React.memo</code>、<code>useMemo</code>、<code>useCallback</code>等手动优化</li><li>需要开发者主动控制组件更新（如<code>shouldComponentUpdate</code>）</li><li>引入<strong>Concurrent Mode</strong>（实验性）实现优先级渲染</li></ul></li></ul><h3 id="二、实现策略差异"><a href="#二、实现策略差异" class="headerlink" title="二、实现策略差异"></a><strong>二、实现策略差异</strong></h3><h4 id="1-模板-vs-JSX"><a href="#1-模板-vs-JSX" class="headerlink" title="1. 模板 vs JSX"></a>1. <strong>模板 vs JSX</strong></h4><ul><li><p><strong>Vue 3</strong>：</p><ul><li><p>主要使用<strong>模板语法</strong>（<code>.vue</code>文件）</p></li><li><p>编译时生成优化的渲染函数</p></li><li><p>示例：</p><p>vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>React</strong>：</p><ul><li><p>主要使用<strong>JSX</strong>（JavaScript 语法扩展）</p></li><li><p>运行时编译 JSX 为<code>React.createElement</code>调用</p></li><li><p>示例：</p><p>jsx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  return &lt;div&gt;&#123;message&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-响应式系统"><a href="#2-响应式系统" class="headerlink" title="2. 响应式系统"></a>2. <strong>响应式系统</strong></h4><ul><li><p><strong>Vue 3</strong>：</p><ul><li><p>内置<strong>Proxy-based 响应式系统</strong></p></li><li><p>自动追踪依赖，精确触发更新</p></li><li><p>示例：</p><p>javascript</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive &#125; from &apos;vue&apos;</span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line">// state.count变化时自动触发更新</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>React</strong>：</p><ul><li><p>使用<strong>不可变数据</strong>和<strong>状态管理库</strong>（如 Redux）</p></li><li><p>通过<code>setState</code>或<code>useState</code>显式触发更新</p></li><li><p>示例：</p><p>javascript</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [count, setCount] = useState(0)</span><br><span class="line">// 必须调用setCount才能触发更新</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="三、性能优化差异"><a href="#三、性能优化差异" class="headerlink" title="三、性能优化差异"></a><strong>三、性能优化差异</strong></h3><h4 id="1-静态内容处理"><a href="#1-静态内容处理" class="headerlink" title="1. 静态内容处理"></a>1. <strong>静态内容处理</strong></h4><ul><li><p><strong>Vue 3</strong>：</p><ul><li><p>编译时识别静态节点并提升（Static Hoisting）</p></li><li><p>静态节点只创建一次，后续渲染直接复用</p></li><li><p>示例：</p><p>vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Static Title&lt;/h1&gt; &lt;!-- 编译时提升 --&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; dynamic &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>React</strong>：</p><ul><li>没有编译时优化，静态节点每次渲染都会重新创建</li><li>需手动使用<code>React.memo</code>或提取组件避免重复渲染</li></ul></li></ul><h4 id="2-事件处理优化"><a href="#2-事件处理优化" class="headerlink" title="2. 事件处理优化"></a>2. <strong>事件处理优化</strong></h4><ul><li><p><strong>Vue 3</strong>：</p><ul><li><p>自动缓存事件处理函数（<code>cacheHandlers</code>）</p></li><li><p>示例：</p><p>vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick&quot;&gt;Click&lt;/button&gt;</span><br><span class="line">&lt;!-- 编译后自动缓存handleClick --&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>React</strong>：</p><ul><li><p>需要手动使用<code>useCallback</code>缓存回调函数</p></li><li><p>示例：</p><p>jsx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const handleClick = useCallback(() =&gt; &#123;</span><br><span class="line">  // 处理逻辑</span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="四、架构设计差异"><a href="#四、架构设计差异" class="headerlink" title="四、架构设计差异"></a><strong>四、架构设计差异</strong></h3><h4 id="1-组件更新粒度"><a href="#1-组件更新粒度" class="headerlink" title="1. 组件更新粒度"></a>1. <strong>组件更新粒度</strong></h4><ul><li><p><strong>Vue 3</strong>：</p><ul><li>组件级更新：单个组件状态变化只会触发该组件重新渲染</li><li>基于响应式系统精确追踪依赖</li></ul></li><li><p><strong>React</strong>：</p><ul><li>函数式组件默认全量重新渲染</li><li>需要通过<code>React.memo</code>、<code>useMemo</code>等手动控制</li></ul></li></ul><h4 id="2-异步渲染"><a href="#2-异步渲染" class="headerlink" title="2. 异步渲染"></a>2. <strong>异步渲染</strong></h4><ul><li><p><strong>Vue 3</strong>：</p><ul><li>渲染过程是<strong>同步</strong>的，但更新是<strong>异步批量</strong>的</li><li>通过<code>nextTick</code>访问更新后的 DOM</li></ul></li><li><p><strong>React</strong>：</p><ul><li><strong>Concurrent Mode</strong>（实验性）支持异步渲染</li><li>可中断渲染过程，优先处理高优先级任务</li></ul></li></ul><h3 id="五、总结对比表"><a href="#五、总结对比表" class="headerlink" title="五、总结对比表"></a><strong>五、总结对比表</strong></h3><table><thead><tr><th>特性</th><th>Vue 3</th><th>React</th></tr></thead><tbody><tr><td><strong>Diff 算法</strong></td><td>预处理 + LIS（O (n log n)）</td><td>双指针 + key（O (n)）</td></tr><tr><td><strong>优化方式</strong></td><td>编译时自动优化（静态提升、Block）</td><td>运行时手动优化（React.memo）</td></tr><tr><td><strong>响应式系统</strong></td><td>内置 Proxy-based 响应式</td><td>不可变数据 + 显式 setState</td></tr><tr><td><strong>模板语法</strong></td><td>声明式模板</td><td>JSX</td></tr><tr><td><strong>更新粒度</strong></td><td>组件级</td><td>函数式组件默认全量更新</td></tr><tr><td><strong>异步渲染</strong></td><td>异步批量更新</td><td>Concurrent Mode（实验性）</td></tr></tbody></table><h3 id="六、适用场景"><a href="#六、适用场景" class="headerlink" title="六、适用场景"></a><strong>六、适用场景</strong></h3><ul><li><p><strong>Vue 3</strong>：</p><ul><li>适合需要高性能渲染的大型应用</li><li>对开发效率有较高要求（编译时优化减少手动工作）</li><li>偏好声明式模板语法的开发者</li></ul></li><li><p><strong>React</strong>：</p><ul><li>适合需要灵活控制渲染过程的应用</li><li>团队熟悉 JavaScript / 函数式编程</li><li>需要与复杂状态管理库集成的场景</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue 3 和 React 的虚拟 DOM 在核心概念上类似，但在实现细节、优化策略和使用方式上存在显著差异。以下是两者的关键对比：&lt;/p&gt;
&lt;h3 id=&quot;一、核心实现差异&quot;&gt;&lt;a href=&quot;#一、核心实现差异&quot; class=&quot;headerlink&quot; title=&quot;一、</summary>
      
    
    
    
    <category term="前端" scheme="https://gofugui.github.io/categories/前端/"/>
    
    
    <category term="ES6" scheme="https://gofugui.github.io/tags/ES6/"/>
    
    <category term="html" scheme="https://gofugui.github.io/tags/html/"/>
    
    <category term="vue3" scheme="https://gofugui.github.io/tags/vue3/"/>
    
    <category term="react" scheme="https://gofugui.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>ES6中Reflect对象与Proxy结合实现代理和响应式编程</title>
    <link href="https://gofugui.github.io/2025/05/21/ES6%E4%B8%ADReflect%E5%AF%B9%E8%B1%A1%E4%B8%8EProxy%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://gofugui.github.io/2025/05/21/ES6%E4%B8%ADReflect%E5%AF%B9%E8%B1%A1%E4%B8%8EProxy%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2025-05-20T16:00:00.000Z</published>
    <updated>2025-05-22T14:21:32.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 JavaScript 中，<strong><code>Reflect</code></strong> 是一个内置对象，提供了拦截和操作 JavaScript 对象的元方法。它是 ES6 (ES2015) 引入的特性，主要用于简化元编程（meta-programming）并与 <strong>Proxy</strong> 结合使用实现对对象属性更细粒度的操作控制。</p><h1 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h1><p><strong>Proxy</strong> 的第一个参数为要进行代理的目标对象，类型为Object，如果我们代理的目标是一个基础数据类型那应该怎么实现呢？</p><h3 id="基础数据类型的代理"><a href="#基础数据类型的代理" class="headerlink" title="基础数据类型的代理"></a>基础数据类型的代理</h3><p>在 JavaScript 中，<strong>基础数据类型（如 <code>number</code>、<code>string</code>、<code>boolean</code> 等）无法直接被 <code>Proxy</code> 代理</strong>，因为 <code>Proxy</code> 只能拦截对象（包括数组、函数、类等）的操作。但可以通过对象封装的方式间接代理基础类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target  = &#123;</span><br><span class="line">    value: <span class="string">'123'</span> <span class="comment">// 这里可以是number 、string、boolean...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key, receiver)&#123;</span><br><span class="line">        <span class="comment">// receiver 指向 proxy实例</span></span><br><span class="line">        <span class="comment">// 思考 ？ 此处可否直接返回 target[key]</span></span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> (target, key, value, receiver)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上述代码中有一个疑问，能否通过<code>return target[key]</code> 取代 <code>return Reflect.get(target, key, receiver)</code>? 事实上这里<code>target[key] 等价于 Reflect.get(target, key)</code>, <code>receiver</code>是指向代理的实例，相当于<code>call/apply</code>的第一个参数，用于指定函数执行的上下文,上面例子中如果不涉及this指向，仅仅是对于简单类型的代理可使用<code>Reflect.get(target, key) 或 target[key]（但不推荐）</code>，接下来我们看下面这个例子说明不推荐的原因：</p><h3 id="复杂数据类型的代理"><a href="#复杂数据类型的代理" class="headerlink" title="复杂数据类型的代理"></a>复杂数据类型的代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people  = &#123;</span><br><span class="line">    <span class="keyword">get</span> name()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'thisArg:'</span>, <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    _name:<span class="string">'xixi'</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(people, &#123;</span><br><span class="line">     <span class="keyword">get</span> (target, key, receiver)&#123;</span><br><span class="line">      <span class="comment">// 思考 ？ 此处可否直接返回 target[key]</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get name:'</span>, target, receiver)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">     &#125;,</span><br><span class="line">     </span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(proxy1.name)</span><br><span class="line"> <span class="comment">// 输出：</span></span><br><span class="line"> <span class="comment">// get name: &#123; name: [Getter], _name: 'xixi' &#125; name &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// thisArg: &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// get name: &#123; name: [Getter], _name: 'xixi' &#125; _name &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// xixi</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> proxy2 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(people, &#123;</span><br><span class="line">     <span class="keyword">get</span> (target, key, receiver)&#123;</span><br><span class="line">      <span class="comment">// 思考 ？ 此处可否直接返回 target[key]</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get name:'</span>, target, receiver)</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">     &#125;,</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(proxy2.name)</span><br><span class="line"> <span class="comment">// 输出：</span></span><br><span class="line"> <span class="comment">// get name: &#123; name: [Getter], _name: 'xixi' &#125; name &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// thisArg: &#123; name: [Getter], _name: 'xixi' &#125;</span></span><br><span class="line"> <span class="comment">// xixi</span></span><br></pre></td></tr></table></figure><p>结论：通过对比输出结果，可以看出直接<code>return target[key]</code>会导致<code>this</code>无法绑定在代理对象上，当修改属性时代理事件就无法触发导致错误，所以建议直接按照<code>Reflect.get(target, key, receiver)</code>处理。</p><h1 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h1><p>此处我们以<code>vue3</code>的响应式编程为例，自定义实现ref和reactive的简化版:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 存储依赖关系的 WeakMap</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在收集依赖的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 副作用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  activeEffect = fn;</span><br><span class="line">  fn(); <span class="comment">// 执行副作用，触发依赖收集</span></span><br><span class="line">  activeEffect = <span class="literal">null</span>; <span class="comment">// 清空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖收集函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dep.add(activeEffect); <span class="comment">// 将副作用添加到依赖集合</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发依赖更新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> dep = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">    dep.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> effect()); <span class="comment">// 执行所有依赖副作用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版 reactive</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key, receiver) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">      track(target, key); <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">      <span class="keyword">if</span> (oldValue !== value) &#123;</span><br><span class="line">        trigger(target, key); <span class="comment">// 触发更新</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版 ref</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _value = &#123; <span class="attr">value</span>: initialValue &#125;; <span class="comment">// 创建一个包裹对象</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对于对象类型，使用 reactive 转换为响应式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialValue === <span class="string">'object'</span> &amp;&amp; initialValue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    _value.value = reactive(initialValue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(_value, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">      track(target, key); <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">      <span class="comment">// 对于对象类型，使用 reactive 转换</span></span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'value'</span> &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">        target[key] = reactive(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">      trigger(target, key); <span class="comment">// 触发更新</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 JavaScript 中，&lt;strong&gt;&lt;code&gt;Reflect&lt;/code&gt;&lt;/strong&gt; 是一个内置对象，提供了拦截和操作 </summary>
      
    
    
    
    <category term="前端" scheme="https://gofugui.github.io/categories/前端/"/>
    
    
    <category term="JavaScript" scheme="https://gofugui.github.io/tags/JavaScript/"/>
    
    <category term="Web" scheme="https://gofugui.github.io/tags/Web/"/>
    
    <category term="ES6" scheme="https://gofugui.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>前端技术分享MediaRecord实现运动相机</title>
    <link href="https://gofugui.github.io/2024/07/27/%E4%BD%BF%E7%94%A8MediaRecord%E5%AE%9E%E7%8E%B0%E8%BF%90%E5%8A%A8%E7%9B%B8%E6%9C%BA%E5%8A%9F%E8%83%BD%20copy/"/>
    <id>https://gofugui.github.io/2024/07/27/%E4%BD%BF%E7%94%A8MediaRecord%E5%AE%9E%E7%8E%B0%E8%BF%90%E5%8A%A8%E7%9B%B8%E6%9C%BA%E5%8A%9F%E8%83%BD%20copy/</id>
    <published>2024-07-27T06:52:14.975Z</published>
    <updated>2024-07-27T06:52:14.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目体验地址"><a href="#项目体验地址" class="headerlink" title="项目体验地址"></a>项目体验地址</h3><p><a href="/webrtc/index.html">运动相机体验地址2</a><br><a href="/dist/index.html">运动相机体验地址(新)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;项目体验地址&quot;&gt;&lt;a href=&quot;#项目体验地址&quot; class=&quot;headerlink&quot; title=&quot;项目体验地址&quot;&gt;&lt;/a&gt;项目体验地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;/webrtc/index.html&quot;&gt;运动相机体验地址2&lt;/a&gt;&lt;br&gt;&lt;a href=</summary>
      
    
    
    
    <category term="前端" scheme="https://gofugui.github.io/categories/前端/"/>
    
    
    <category term="JavaScript" scheme="https://gofugui.github.io/tags/JavaScript/"/>
    
    <category term="Web" scheme="https://gofugui.github.io/tags/Web/"/>
    
    <category term="ES6" scheme="https://gofugui.github.io/tags/ES6/"/>
    
    <category term="html" scheme="https://gofugui.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>react基础概念</title>
    <link href="https://gofugui.github.io/2024/07/03/react%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://gofugui.github.io/2024/07/03/react%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2024-07-03T08:26:21.233Z</published>
    <updated>2024-07-07T05:12:34.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="react-fiber算法"><a href="#react-fiber算法" class="headerlink" title="react fiber算法"></a>react fiber算法</h3><pre><code class="bash">1、在早期版本中，react渲染的方式是递归方式，每次渲染都会重新创建组件，然后进行diff比较，最后更新视图，整个过程是一气呵成，中间不许中止或暂停，但是随着react的更新，业务越来越复杂，这种方式在处理复杂视图和大数据量业务时会面临阻塞和卡顿的问题，为了解决这一问题，react开始使用fiber算法，fiber算法可以理解为react的虚拟dom，react会根据fiber算法来确定组件的更新顺序，如果主线程上有输入等更高优先级的任务则会让渡出执行权，让主线程执行其他任务。2、在本质上fiber是一个javascript对象，代表着react的工作单元，它包含了组件的信息。react可以在处理任何fiber对象之前判断是否有足够的时间完成改工作，并在必要时恢复和中断该工作。</code></pre><h3 id="react-hooks使用"><a href="#react-hooks使用" class="headerlink" title="react hooks使用"></a>react hooks使用</h3><pre><code class="bash"><span class="comment"># react hooks不能放在循环、条件判断、函数内部</span>（1）、确保hooks执行顺序的稳定性：react需要根据Hooks的调用顺序来维护内部的状态。将hooks放在条件语句或循环中可能导致每次渲染时hooks执行顺序变化，这会破坏React对状态的管理，使得组件状态变得不可预测。（2）、维护hooks的调用链表：react内部使用一个链表来跟踪每个hooks调用，确保在组件的每次更新时能准确的恢复状态。条件或循环内的hooks会打破这一机制，因为它们可能不会按照上次渲染的顺序被调用。（3）、函数组件的纯函数特性：函数组件应被视为纯函数，对于相同的输入应当产生相同的输出，条件性的使用hooks会使得组件行为依赖于外部条件，而不是状态，这破坏了组件的封装性和可预测性。（4）便于理解和调试。<span class="comment"># 在React开发中使用React Hooks可以带来以下优势：</span>简化代码：相比于传统的类组件，使用React Hooks可以更简洁地管理组件的状态和生命周期方法，减少了冗余代码。提高可重用性：React Hooks可以将组件逻辑进行封装，使得逻辑可以在多个组件中共享和复用。方便测试：由于React Hooks使组件的逻辑更加纯粹，没有副作用，因此更容易进行单元测试和集成测试。<span class="comment"># React Hooks的应用场景包括但不限于：</span>简单的组件：对于只有少量状态和生命周期方法的组件，使用React Hooks可以更加简洁地实现。复杂的组件逻辑：对于需要管理多个状态和处理复杂逻辑的组件，使用React Hooks可以更好地组织代码。函数式组件：React Hooks主要适用于函数式组件，可以让函数式组件具备类组件的功能。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;react-fiber算法&quot;&gt;&lt;a href=&quot;#react-fiber算法&quot; class=&quot;headerlink&quot; title=&quot;react fiber算法&quot;&gt;&lt;/a&gt;react fiber算法&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;1、在早期</summary>
      
    
    
    
    <category term="前端" scheme="https://gofugui.github.io/categories/前端/"/>
    
    
    <category term="JavaScript" scheme="https://gofugui.github.io/tags/JavaScript/"/>
    
    <category term="Web" scheme="https://gofugui.github.io/tags/Web/"/>
    
    <category term="ES6" scheme="https://gofugui.github.io/tags/ES6/"/>
    
    <category term="html" scheme="https://gofugui.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序使用canvas创建像素头像</title>
    <link href="https://gofugui.github.io/2023/08/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8canvas%E5%88%9B%E5%BB%BA%E5%83%8F%E7%B4%A0%E5%A4%B4%E5%83%8F/"/>
    <id>https://gofugui.github.io/2023/08/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8canvas%E5%88%9B%E5%BB%BA%E5%83%8F%E7%B4%A0%E5%A4%B4%E5%83%8F/</id>
    <published>2023-08-05T06:02:28.621Z</published>
    <updated>2024-07-27T07:07:24.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="乐涂画板-小程序创作示例"><a href="#乐涂画板-小程序创作示例" class="headerlink" title="乐涂画板 小程序创作示例"></a>乐涂画板 小程序创作示例</h3><p><img src="https://gofugui.github.io/images/img148.jpg" alt="示例一"><br><img src="https://gofugui.github.io/images/img149.jpg" alt="示例二"><br><img src="https://gofugui.github.io/images/img150.jpg" alt="示例三"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;乐涂画板-小程序创作示例&quot;&gt;&lt;a href=&quot;#乐涂画板-小程序创作示例&quot; class=&quot;headerlink&quot; title=&quot;乐涂画板 小程序创作示例&quot;&gt;&lt;/a&gt;乐涂画板 小程序创作示例&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://gofugui.gith</summary>
      
    
    
    
    <category term="前端" scheme="https://gofugui.github.io/categories/前端/"/>
    
    
    <category term="JavaScript" scheme="https://gofugui.github.io/tags/JavaScript/"/>
    
    <category term="Web" scheme="https://gofugui.github.io/tags/Web/"/>
    
    <category term="ES6" scheme="https://gofugui.github.io/tags/ES6/"/>
    
    <category term="html" scheme="https://gofugui.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>前端基础概念</title>
    <link href="https://gofugui.github.io/2021/04/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://gofugui.github.io/2021/04/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-04-08T07:44:39.405Z</published>
    <updated>2024-07-05T12:52:21.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。</span><br><span class="line"></span><br><span class="line">每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。</span><br><span class="line">正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。</span><br><span class="line">当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。</span><br><span class="line">当分配的调用栈空间被占满时，会引发“堆栈溢出”错误。</span><br></pre></td></tr></table></figure><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最新的 ECMAScript 标准定义了 9 种数据类型:</span></span><br><span class="line"><span class="comment"># 6 种原始类型，使用 typeof 运算符检查:</span></span><br><span class="line"></span><br><span class="line">undefined: typeof =&gt; <span class="string">'undefined'</span></span><br><span class="line">Boolean: typeof =&gt; <span class="string">'boolean'</span></span><br><span class="line">Number: typeof =&gt; <span class="string">'number'</span></span><br><span class="line">String: typeof =&gt; <span class="string">'string'</span></span><br><span class="line">BigInt: typeof =&gt; <span class="string">'bigint'</span></span><br><span class="line">Symbol: typeof =&gt; <span class="string">'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象和函数类型</span></span><br><span class="line">null: typeof =&gt; <span class="string">'object'</span></span><br><span class="line">Object: typeof =&gt; <span class="string">'object'</span></span><br><span class="line">Function: typeof =&gt; <span class="string">'function'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 内建对象 typeof =&gt; 'function'</span></span><br><span class="line">Date</span><br><span class="line">Array </span><br><span class="line">Map</span><br><span class="line">Set</span><br><span class="line">WeakMap</span><br><span class="line">WeakSet</span><br><span class="line">Regxp</span><br></pre></td></tr></table></figure><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值类型：</span></span><br><span class="line">string, number, boolean, undefined, bigint, symbol 和 null</span><br><span class="line"><span class="comment"># 引用类型：</span></span><br><span class="line">Object, Array, Function,...</span><br></pre></td></tr></table></figure><h3 id="隐式-显式-名义和鸭子类型"><a href="#隐式-显式-名义和鸭子类型" class="headerlink" title="隐式, 显式, 名义和鸭子类型"></a>隐式, 显式, 名义和鸭子类型</h3><p><strong>JavaScript 是一种<code>弱类型</code>或者说<code>动态</code>语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = 42;   <span class="comment"># foo is a Number now</span></span><br><span class="line">foo = <span class="string">"bar"</span>;    <span class="comment"># foo is a String now</span></span><br><span class="line">foo = <span class="literal">true</span>;     <span class="comment"># foo is a Boolean now</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐式转换为布尔：“truthy”和“falsy”。当 JavaScript 需要一个布尔值时（例如：if 语句），任何值都可以被使用。 最终这些值将被转换为 true 或 false。</span></span><br><span class="line"><span class="string">''</span>, +0, -0, NaN, null, undefined, 0, 转换为boolean类型的时候都是<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="与-typeof-与-instanceof"><a href="#与-typeof-与-instanceof" class="headerlink" title="== 与 ===, typeof 与 instanceof"></a>== 与 ===, typeof 与 instanceof</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># == 会进行隐式转换</span></span><br><span class="line">    1.如果比较的两者中有布尔值(Boolean)，会把 Boolean 先转换为对应的 Number，即 0 和 1，然后进行比较。</span><br><span class="line">    2.如果比较的双方中有一方为 Number，一方为 String时，会把 String 通过 Number() 方法转换为数字，然后进行比较。</span><br><span class="line">    3.如果比较的双方中有一方为 Boolean，一方为 String时，会将双方转换为数字，然后再进行比较。</span><br><span class="line">    4.如果比较的双方中有一方为 Number，一方为Object时，则会调用 valueOf 方法将Object转换为数字，然后进行比较。 </span><br><span class="line"><span class="comment"># === 不会进行转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># typeof 返回数据类型的 类型标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># instanceof 运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上</span></span><br></pre></td></tr></table></figure><h3 id="this-call-apply-和-bind"><a href="#this-call-apply-和-bind" class="headerlink" title="this, call, apply 和 bind"></a>this, call, apply 和 bind</h3><p><strong>与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别。</strong><br><strong>在绝大多数情况下，函数的调用方式决定了this的值  <code>（运行时绑定）</code>，所以this的值在每次函数调用的时候都可能不同。es5 中引入了bind来设置this的值。</strong><br><strong>需要指出的是在es2015中引入的箭头函数中，不提供自身的this绑定，其this值保持为闭合词法的上下文值</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># call ,apply</span></span><br><span class="line">二者作用类似，都是指定具体this和参数调用函数，区别是call调用时参数以列表的形式传递，而apply则是以数组的形式传递参数</span><br></pre></td></tr></table></figure></p><h3 id="函数作用域-块级作用域和词法作用域"><a href="#函数作用域-块级作用域和词法作用域" class="headerlink" title="函数作用域, 块级作用域和词法作用域"></a>函数作用域, 块级作用域和词法作用域</h3><p>作用域：当前执行的上下文。值和表达式在其中“可见“或者可以被访问到的上下文，js作用域以链的形式存在。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js代码执行时，首先回创建一个全局的执行上下文</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数作用域</span></span><br><span class="line">通常情况下，在函数内部定义的变量不能在函数之外的任何地方访问，同时内部函数包含外部函数作用域。</span><br><span class="line"><span class="comment"># 块级作用域</span></span><br><span class="line">在js中函数块是🈯️被&#123;&#125;包裹住的相关联的状态集合，例如一个<span class="keyword">for</span>循环体，一个条件<span class="keyword">if</span>判断都可以纳入一个块级作用域范围</span><br></pre></td></tr></table></figure></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>你可以在函数的内部再定义一个函数，嵌套函数对其容器函数是私有的，他自身也形成了一个闭包，当闭包内包含外部作用域的参数和变量时，会保存其值，当一个闭包中进行变量查找时，更近的作用域有更高的优先权，这就形成了作用域链</strong></p><h3 id="map-reduce-filter-等高阶函数"><a href="#map-reduce-filter-等高阶函数" class="headerlink" title="map, reduce, filter 等高阶函数"></a>map, reduce, filter 等高阶函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># map</span></span><br><span class="line">map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</span><br><span class="line"><span class="comment"># reduce </span></span><br><span class="line">reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</span><br><span class="line"><span class="comment"># filter</span></span><br><span class="line">filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</span><br></pre></td></tr></table></figure><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><strong>其实质是变量的声明提升</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(b)  <span class="comment"># undefined</span></span><br><span class="line">var b;          <span class="comment"># 声明提升</span></span><br><span class="line"></span><br><span class="line">console.log(c)  <span class="comment"># VM315:1 Uncaught ReferenceError: c is not defined</span></span><br><span class="line"><span class="built_in">let</span> c;          <span class="comment"># let 和 const 声明的无法提升变量声明</span></span><br></pre></td></tr></table></figure></p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><strong>Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个 Promise 必然处于以下几种状态之一：</span><br><span class="line"><span class="comment"># 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。</span></span><br><span class="line"><span class="comment"># 已兑现（fulfilled）: 意味着操作成功完成。</span></span><br><span class="line"><span class="comment"># 已拒绝（rejected）: 意味着操作失败。</span></span><br></pre></td></tr></table></figure></p><h3 id="立即执行函数-模块化-命名空间"><a href="#立即执行函数-模块化-命名空间" class="headerlink" title="立即执行函数, 模块化, 命名空间"></a>立即执行函数, 模块化, 命名空间</h3><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="headerlink" title="消息队列和事件循环"></a>消息队列和事件循环</h3><p><strong>JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其它语言中的模型截然不同，比如 C 和 Java。</strong></p><p>一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。</p><p>在 事件循环 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p><p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 之所以称之为 事件循环，是因为它经常按照类似如下的方式来被实现：</span></span><br><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。</p><h3 id="setTimeout-setInterval-和requestAnimationFrame"><a href="#setTimeout-setInterval-和requestAnimationFrame" class="headerlink" title="setTimeout, setInterval 和requestAnimationFrame"></a>setTimeout, setInterval 和requestAnimationFrame</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setTimeout</span></span><br><span class="line">由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。</span><br><span class="line">定时器</span><br><span class="line">需要做this绑定，或者使用函数包裹，箭头函数解决</span><br><span class="line"><span class="comment"># requestAnimationFrame</span></span><br><span class="line">window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</span><br></pre></td></tr></table></figure><h3 id="多态和代码复用"><a href="#多态和代码复用" class="headerlink" title="多态和代码复用"></a>多态和代码复用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多态</span></span><br></pre></td></tr></table></figure><h3 id="按位操作符-类数组对象和类型化数组"><a href="#按位操作符-类数组对象和类型化数组" class="headerlink" title="按位操作符, 类数组对象和类型化数组"></a>按位操作符, 类数组对象和类型化数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按位与</span></span><br><span class="line">两个操作数都为1时，则在该位返回1</span><br><span class="line"><span class="comment"># 按位或</span></span><br><span class="line">两个操作数对应位只要有一个为1，则在该位返回1</span><br><span class="line"><span class="comment"># 按位异或</span></span><br><span class="line">两个操作数的对应位只有一个为1，则在该位返回1</span><br><span class="line"><span class="comment"># 按位取反</span></span><br><span class="line">遇0则返回1，反之亦然</span><br><span class="line"><span class="comment"># 应用</span></span><br><span class="line">1、通过位运算符取整</span><br><span class="line">3.14|0 ; // 3</span><br></pre></td></tr></table></figure><h3 id="DOM-树和渲染过程"><a href="#DOM-树和渲染过程" class="headerlink" title="DOM 树和渲染过程"></a>DOM 树和渲染过程</h3><p>DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分</p><p>等待资源加载时间和大部分情况下的浏览器单线程执行是影响Web性能的两大主要原因。</p><p>通过了解浏览器单线程的本质与最小化主线程的责任可以优化Web性能，来确保渲染的流畅和交互响应的及时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DNS查找</span></span><br><span class="line">对于一个web页面来说导航的第一步是要去寻找页面资源的位置。如果导航到https://example.com, HTML页面 被定为到IP地址为 93.184.216.34 的服务器。如果以前没有访问过这个网站，就需要进行DNS查找。</span><br><span class="line"><span class="comment"># TCP握手</span></span><br><span class="line">TCP的”三次握手“技术经常被称为”SYN-SYN-ACK“—更确切的说是 SYN, SYN-ACK, ACK—因为通过TCP首先发送了三个消息进行协商，开始一个TCP会话在两台电脑之间。 是的，这意味着每台服务器之间还要来回发送三条消息，而请求尚未发出。</span><br><span class="line"><span class="comment"># TLS协商</span></span><br><span class="line">为了在HTTPS上建立安全连接，另一种握手是必须的。更确切的说是TLS协商 ，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。</span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">一旦我们建立了到web服务器的连接，浏览器就代表用户发送一个初始的HTTP GET请求，对于网站来说，这个请求通常是一个HTML文件。 一旦服务器收到请求，它将使用相关的响应头和HTML的内容进行回复。</span><br><span class="line"><span class="comment"># tcp慢开始/14kb规则</span></span><br><span class="line">第一个响应包是14kb大小。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。</span><br><span class="line"><span class="comment"># 拥塞控制</span></span><br><span class="line">当服务器用TCP包来发送数据时，客户端通过返回确认帧来确认传输。由于硬件和网络条件，连接的容量是有限的。 如果服务器太快地发送太多的包，它们可能会被丢弃。意味着，将不会有确认帧的返回。服务器把它们当做确认帧丢失。拥塞控制算法使用这个发送包和确认帧流来确定发送速率。</span><br><span class="line"><span class="comment"># 解析</span></span><br><span class="line">一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。</span><br><span class="line">“推测性解析”，“解析”是浏览器将通过网络接收的数据转换为DOM和CSSOM的步骤，通过渲染器把DOM和CSSOM在屏幕上绘制成页面。</span><br><span class="line">即使请求页面的HTML大于初始的14KB数据包，浏览器也将开始解析并尝试根据其拥有的数据进行渲染。这就是为什么在前14Kb中包含浏览器开始渲染页面所需的所有内容，或者至少包含页面模板（第一次渲染所需的CSS和HTML）对于web性能优化来说是重要的。但是在渲染到屏幕上面之前，HTML、CSS、JavaScript必须被解析完成。</span><br><span class="line"><span class="comment"># 构建DOM树</span></span><br><span class="line">第一步是处理HTML标记并构造DOM树。HTML解析涉及到 tokenization 和树的构造。HTML标记包括开始和结束标记，以及属性名和值。 如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建文档树。</span><br><span class="line">当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个CSS文件时，解析也可以继续进行，但是对于&lt;script&gt;标签（特别是没有 async 或者 defer 属性）会阻塞渲染并停止HTML的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。</span><br><span class="line"><span class="comment"># 预加载扫描器</span></span><br><span class="line"><span class="comment"># 构建cssom树</span></span><br><span class="line">DOM和CSSOM是两棵树. 它们是独立的数据结构。浏览器将CSS规则转换为可以理解和使用的样式映射。浏览器遍历CSS中的每个规则集，根据CSS选择器创建具有父、子和兄弟关系的节点树。</span><br><span class="line"><span class="comment"># javascript编译</span></span><br><span class="line">当CSS被解析并创建CSSOM时，其他资源，包括JavaScript文件正在下载（多亏了preload scanner）。JavaScript被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用”Abstract Syntax Tree“并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的JavaScript编译。</span><br><span class="line"><span class="comment"># 渲染</span></span><br><span class="line">渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。</span><br><span class="line">在解析步骤中创建的CSSOM树和DOM树组合成一个Render树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。</span><br><span class="line"></span><br><span class="line">知识点：</span><br><span class="line">Layout</span><br><span class="line">a、回流</span><br><span class="line">回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。</span><br><span class="line">b、重绘</span><br></pre></td></tr></table></figure><h3 id="new-与构造函数-instanceof-与实例"><a href="#new-与构造函数-instanceof-与实例" class="headerlink" title="new 与构造函数, instanceof 与实例"></a>new 与构造函数, instanceof 与实例</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  new 关键字会进行如下的操作：</span></span><br><span class="line"></span><br><span class="line">1、创建一个空的简单JavaScript对象（即&#123;&#125;）；</span><br><span class="line">2、链接该对象（设置该对象的constructor）到另一个对象 ；</span><br><span class="line">3、将步骤1新创建的对象作为this的上下文 ；</span><br><span class="line">4、如果该函数没有返回对象，则返回this。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当代码 new Foo(...) 执行时，会发生以下事情：</span></span><br><span class="line"></span><br><span class="line">1、一个继承自 Foo.prototype 的新对象被创建。</span><br><span class="line">2、使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</span><br><span class="line">3、由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</span><br></pre></td></tr></table></figure></p><h3 id="原型继承与原型链"><a href="#原型继承与原型链" class="headerlink" title="原型继承与原型链"></a>原型继承与原型链</h3><p>有些人认为JavaScript并不是真正的面向对象语言，在经典的面向对象语言中，您可能倾向于定义类对象,然后您可以简单地定义哪些类继承哪些类，JavaScript使用了另一套实现方式，继承的对象函数并不是通过复制而来，而是通过原型链继承（在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的）</p><p><strong>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 `</strong>proto__<code>）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象(</code><strong>proto</strong>` ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。__</p><p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。</p><p><strong>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</strong></p><p>Object.prototype 属性表示 Object 的原型对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原型链继承</span></span><br><span class="line"><span class="keyword">function</span> Person(first, last, age, gender, interests) &#123;</span><br><span class="line">  this.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.gender = gender;</span><br><span class="line">  this.interests = interests;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.greeting = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // <span class="keyword">do</span> something</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过call和apply继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Teacher(first, last, age, gender, interests, subject) &#123;</span><br><span class="line">  Person.call(this, first, last, age, gender, interests);</span><br><span class="line"></span><br><span class="line">  this.subject = subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>注：每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。当我们输入类似var person1=new Person(…)来构造对象时，JavaScript实际上参考的是Person.prototype指向的对象来生成person1。另一方面，Person()函数是Person.prototype的构造函数，也就是说Person===Person.prototype.constructor（不信的话可以试试）。在定义新的构造函数Teacher时，我们通过function.call来调用父类的构造函数，但是这样无法自动指定Teacher.prototype的值，这样Teacher.prototype就只能包含在构造函数里构造的属性，而没有方法。因此我们利用Object.create()方法将Person.prototype作为Teacher.prototype的原型对象，并改变其构造器指向，使之与Teacher关联。</strong></p><p> <strong><font color="red">*</font> 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</strong></p><h3 id="Object-create-和-Object-assign"><a href="#Object-create-和-Object-assign" class="headerlink" title="Object.create 和 Object.assign"></a>Object.create 和 Object.assign</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__（原型对象）。新对象的原型就是调用 create 方法时传入的第一个参数：</span></span><br><span class="line">var a = &#123;a: 1&#125;;</span><br><span class="line">// a ---&gt; Object.prototype ---&gt; null</span><br><span class="line"></span><br><span class="line">var b = Object.create(a);</span><br><span class="line">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span><br><span class="line">console.log(b.a); // 1 (继承而来)</span><br></pre></td></tr></table></figure><h3 id="工厂函数和类"><a href="#工厂函数和类" class="headerlink" title="工厂函数和类"></a>工厂函数和类</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h3><h3 id="纯函数-函数副作用和状态变化"><a href="#纯函数-函数副作用和状态变化" class="headerlink" title="纯函数, 函数副作用和状态变化"></a>纯函数, 函数副作用和状态变化</h3><h3 id="耗性能操作和时间复杂度"><a href="#耗性能操作和时间复杂度" class="headerlink" title="耗性能操作和时间复杂度"></a>耗性能操作和时间复杂度</h3><h3 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h3><h3 id="二进制-十进制-十六进制-科学记数法"><a href="#二进制-十进制-十六进制-科学记数法" class="headerlink" title="二进制, 十进制, 十六进制, 科学记数法"></a>二进制, 十进制, 十六进制, 科学记数法</h3><h3 id="偏函数-柯里化-Compose-和-Pipe"><a href="#偏函数-柯里化-Compose-和-Pipe" class="headerlink" title="偏函数, 柯里化, Compose 和 Pipe"></a>偏函数, 柯里化, Compose 和 Pipe</h3><h3 id="代码整洁之道"><a href="#代码整洁之道" class="headerlink" title="代码整洁之道"></a>代码整洁之道</h3><h3 id="promise执行顺序"><a href="#promise执行顺序" class="headerlink" title="promise执行顺序"></a>promise执行顺序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 500)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    resolve(3)</span><br><span class="line">&#125;).<span class="keyword">then</span>(res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    <span class="built_in">return</span> 4</span><br><span class="line">&#125;).<span class="keyword">then</span>(res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    resolve(5)</span><br><span class="line">&#125;).<span class="keyword">then</span>(res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    <span class="built_in">return</span> 6</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;调用堆栈&quot;&gt;&lt;a href=&quot;#调用堆栈&quot; class=&quot;headerlink&quot; title=&quot;调用堆栈&quot;&gt;&lt;/a&gt;调用堆栈&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="前端" scheme="https://gofugui.github.io/categories/前端/"/>
    
    
    <category term="JavaScript" scheme="https://gofugui.github.io/tags/JavaScript/"/>
    
    <category term="Web" scheme="https://gofugui.github.io/tags/Web/"/>
    
    <category term="ES6" scheme="https://gofugui.github.io/tags/ES6/"/>
    
    <category term="html" scheme="https://gofugui.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>中高级前端须注意的40条移动端H5坑位指南</title>
    <link href="https://gofugui.github.io/2021/03/30/%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E9%A1%BB%E6%B3%A8%E6%84%8F%E7%9A%8440%E6%9D%A1%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E5%9D%91%E4%BD%8D%E6%8C%87%E5%8D%97/"/>
    <id>https://gofugui.github.io/2021/03/30/%E4%B8%AD%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E9%A1%BB%E6%B3%A8%E6%84%8F%E7%9A%8440%E6%9D%A1%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E5%9D%91%E4%BD%8D%E6%8C%87%E5%8D%97/</id>
    <published>2021-03-30T08:50:07.935Z</published>
    <updated>2021-03-31T05:06:27.636Z</updated>
    
    <content type="html"><![CDATA[<p><code>移动端开发在前端里像神一样地存在，不是说它多难而是说它坑位实在太多了，怎样填都填不完。Android和iOS各显神通，Android的系统版本和屏幕分辨率多得难以一招兼容，iOS的顽固标准和未知特性多得难以快速掌握。</code></p><p><code>三年半沉淀通过本文记录下所遇到的坑位，或许有些坑位还未遇到，但本文记录的「40条坑位」绝对能让同学们少走很多弯路，特别是前端小白。为了减少废话提高本文质量，对以下内容做一些约定。</code></p><h2 id="HTML方向"><a href="#HTML方向" class="headerlink" title="HTML方向"></a>HTML方向</h2><h4 id="调用系统功能"><a href="#调用系统功能" class="headerlink" title="调用系统功能"></a>调用系统功能</h4><p>使用<code>&lt;a&gt;</code>能快速调用移动设备的<code>电话/短信/邮件</code>三大通讯功能，使用<code>&lt;input&gt;</code>能快速调用移动设备的的图库/文件。</p><p>这些功能方便了页面与系统的交互，关键在于调用格式一定要准确，否则会被移动端浏览器忽略。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 拨打电话 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"tel:10086"</span>&gt;拨打电话给10086小姐姐&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 发送短信 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"sms:10086"</span>&gt;发送短信给10086小姐姐&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 发送邮件 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"mailto:young.joway@aliyun.com"</span>&gt;发送邮件给JowayYoung&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 选择照片或拍摄照片 --&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"file"</span> accept=<span class="string">"image/*"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 选择视频或拍摄视频 --&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"file"</span> accept=<span class="string">"video/*"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 多选文件 --&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"file"</span> multiple&gt;</span><br></pre></td></tr></table></figure><h4 id="忽略自动识别"><a href="#忽略自动识别" class="headerlink" title="忽略自动识别"></a>忽略自动识别</h4><p>有些移动端浏览器会自动将数字字母符号识别为电话/邮箱并将其渲染成上述「调用系统功能」里的<code>&lt;a&gt;</code>。虽然很方便却有可能违背需求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 忽略自动识别电话 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"format-detection"</span> content=<span class="string">"telephone=no"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 忽略自动识别邮箱 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"format-detection"</span> content=<span class="string">"email=no"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 忽略自动识别电话和邮箱 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"format-detection"</span> content=<span class="string">"telephone=no, email=no"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="弹出数字键盘"><a href="#弹出数字键盘" class="headerlink" title="弹出数字键盘"></a>弹出数字键盘</h4><p>使用<code>&lt;input type=&quot;tel&quot;&gt;</code>弹起数字键盘会带上#和<em>，适合输入电话。推荐使用 `&lt;input type=”number” pattern=”\d</em>“&gt;`弹起数字键盘，适合输入验证码等纯数字格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 纯数字带<span class="comment">#和* --&gt;</span></span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"tel"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 纯数字 --&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"number"</span> pattern=<span class="string">"\d*"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="唤醒原生应用"><a href="#唤醒原生应用" class="headerlink" title="唤醒原生应用"></a>唤醒原生应用</h4><p>通过<code>location.href</code>与原生应用建立通讯渠道，这种页面与客户端的通讯方式称为<code>「URL Scheme」</code>，其基本格式为<code>scheme://[path][?query]</code>，笔者曾经发表过《H5与App的通讯方式》讲述<code>URL Scheme</code>的使用。</p><ul><li><code>「scheme」</code>：应用标识，表示应用在系统里的唯一标识</li><li><code>「path」</code> ：应用行为，表示应用某个页面或功能</li><li><code>「query」</code>：应用参数，表示应用页面或应用功能所需的条件参数</li></ul><p><code>URL Scheme</code>一般由前端与客户端共同协商。唤醒原生应用的前提是必须在移动设备里安装了该应用，有些移动端浏览器即使安装了该应用也无法唤醒原生应用，因为它认为<code>URL Scheme</code>是一种潜在的危险行为而禁用它，像Safari和微信浏览器。还好微信浏览器可开启白名单让<code>URL Scheme</code>有效。</p><p>若在页面引用第三方原生应用的<code>URL Schema</code>，可通过抓包第三方原生应用获取其<code>URL</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 打开微信 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"weixin://"</span>&gt;打开微信&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 打开支付宝 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"alipays://"</span>&gt;打开支付宝&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 打开支付宝的扫一扫 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"alipays://platformapi/startapp?saId=10000007"</span>&gt;打开支付宝的扫一扫&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 打开支付宝的蚂蚁森林 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"alipays://platformapi/startapp?appId=60000002"</span>&gt;打开支付宝的蚂蚁森林&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="禁止页面缩放"><a href="#禁止页面缩放" class="headerlink" title="禁止页面缩放"></a>禁止页面缩放</h4><p>在智能手机的普及下，很多网站都具备<code>桌面端</code>和<code>移动端</code>两种浏览版本，因此无需双击缩放查看页面。禁止页面缩放可保障<code>移动端</code>浏览器能无遗漏地展现页面所有布局。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="禁止页面缓存"><a href="#禁止页面缓存" class="headerlink" title="禁止页面缓存"></a>禁止页面缓存</h4><p><code>「Cache-Control」</code>指定请求和响应遵循的缓存机制，不想使用浏览器缓存就禁止呗！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Cache-Control"</span> content=<span class="string">"no-cache"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="禁止字母大写"><a href="#禁止字母大写" class="headerlink" title="禁止字母大写"></a>禁止字母大写</h4><p>有时在输入框里输入文本会默认开启首字母大写纠正，就是输入首字母小写会被自动纠正成大写，特么的烦。直接声明<code>autocapitalize=off</code>关闭首字母大写功能和<code>autocorrect=off</code>关闭纠正功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input autocapitalize=<span class="string">"off"</span> autocorrect=<span class="string">"off"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="针对Safari配置"><a href="#针对Safari配置" class="headerlink" title="针对Safari配置"></a>针对Safari配置</h4><p>贴一些Safari较零散且少用的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 设置Safari全屏，在iOS7+无效 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"apple-mobile-web-app-capable"</span> content=<span class="string">"yes"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 改变Safari状态栏样式，可选default/black/black-translucent，需在上述全屏模式下才有效 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"apple-mobile-web-app-status-bar-style"</span> content=<span class="string">"black"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加页面启动占位图 --&gt;</span><br><span class="line">&lt;link rel=<span class="string">"apple-touch-startup-image"</span> href=<span class="string">"pig.jpg"</span> media=<span class="string">"(device-width: 375px)"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 保存网站到桌面时添加图标 --&gt;</span><br><span class="line">&lt;link rel=<span class="string">"apple-touch-icon"</span> sizes=<span class="string">"76x76"</span> href=<span class="string">"pig.jpg"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 保存网站到桌面时添加图标且清除默认光泽 --&gt;</span><br><span class="line">&lt;link rel=<span class="string">"apple-touch-icon-precomposed"</span> href=<span class="string">"pig.jpg"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="针对其他浏览器配置"><a href="#针对其他浏览器配置" class="headerlink" title="针对其他浏览器配置"></a>针对其他浏览器配置</h4><p>贴一些其他浏览器较零散且少用的配置，主要是常用的QQ浏览器、UC浏览器和360浏览器。从网易MTL的测试数据得知，新版的QQ浏览器和UC浏览器已不支持以下<code>&lt;meta&gt;</code>声明了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 强制QQ浏览器竖屏 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"x5-orientation"</span> content=<span class="string">"portrait"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 强制QQ浏览器全屏 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"x5-fullscreen"</span> content=<span class="string">"true"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启QQ浏览器应用模式 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"x5-page-mode"</span> content=<span class="string">"app"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 强制UC浏览器竖屏 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"screen-orientation"</span> content=<span class="string">"portrait"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 强制UC浏览器全屏 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"full-screen"</span> content=<span class="string">"yes"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启UC浏览器应用模式 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"browsermode"</span> content=<span class="string">"application"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启360浏览器极速模式 --&gt;</span><br><span class="line">&lt;meta name=<span class="string">"renderer"</span> content=<span class="string">"webkit"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="让-active有效，让-hover无效"><a href="#让-active有效，让-hover无效" class="headerlink" title="让:active有效，让:hover无效"></a>让:active有效，让:hover无效</h4><p>有些元素的:active可能会无效，而元素的:hover在点击后会一直处于点击状态，需点击其他位置才能解除点击状态。给<body>注册一个空的touchstart事件可将两种状态反转。</body></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body ontouchstart&gt;&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="CSS方向"><a href="#CSS方向" class="headerlink" title="CSS方向"></a>CSS方向</h2><h4 id="自动适应布局"><a href="#自动适应布局" class="headerlink" title="自动适应布局"></a>自动适应布局</h4><p>针对移动端，笔者通常会结合JS依据屏幕宽度与设计图宽度的比例动态声明<code>&lt;html&gt;</code>的<code>font-size</code>，以<code>rem</code>为长度单位声明所有节点的几何属性，这样就能做到大部分移动设备的页面兼容，兼容出入较大的地方再通过媒体查询做特别处理。</p><p>笔者通常将rem布局比例设置成1rem=100px，即在设计图上100px长度在CSS代码上使用1rem表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> AutoResponse(width = 750) &#123;</span><br><span class="line">    const target = document.documentElement;</span><br><span class="line">    <span class="keyword">if</span> (target.clientWidth &gt;= 600) &#123;</span><br><span class="line">        target.style.fontSize = <span class="string">"80px"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target.style.fontSize = target.clientWidth / width * 100 + <span class="string">"px"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AutoResponse();</span><br><span class="line">window.addEventListener(<span class="string">"resize"</span>, () =&gt; AutoResponse());</span><br></pre></td></tr></table></figure><p>当然还可依据屏幕宽度与设计图宽度的比例使用<code>calc()</code>动态声明<code>&lt;html&gt;</code>的<code>font-size</code>，这样就能节省上述代码。不对，是完全代替上述代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    font-size: calc(100vw / 7.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若以iPad Pro分辨率1024px为移动端和桌面端的断点，还可结合媒体查询做断点处理。1024px以下使用rem布局，否则不使用rem布局。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width: 1024px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: calc(100vw / 7.5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动适应背景"><a href="#自动适应背景" class="headerlink" title="自动适应背景"></a>自动适应背景</h4><p>使用rem布局声明一个元素背景，多数情况会将background-size声明为cover。可能在设计图对应分辨率的移动设备下，背景会完美贴合显示，但换到其他分辨率的移动设备下就会出现左右空出1px到npx的空隙。</p><p>此时将background-size声明为100% 100%，跟随width和height的变化而变化。反正width和height都是量好的实际尺寸。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.elem &#123;</span><br><span class="line">    width: 1rem;</span><br><span class="line">    height: 1rem;</span><br><span class="line">    background: url(<span class="string">"pig.jpg"</span>) no-repeat center/100% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监听屏幕旋转"><a href="#监听屏幕旋转" class="headerlink" title="监听屏幕旋转"></a>监听屏幕旋转</h4><p>你还在使用JS判断横屏竖屏调整样式吗？那就真的Out了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 竖屏 */</span><br><span class="line">@media all and (orientation: portrait) &#123;</span><br><span class="line">    /* 自定义样式 */</span><br><span class="line">&#125;</span><br><span class="line">/* 横屏 */</span><br><span class="line">@media all and (orientation: landscape) &#123;</span><br><span class="line">    /* 自定义样式 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="支持弹性滚动"><a href="#支持弹性滚动" class="headerlink" title="支持弹性滚动"></a>支持弹性滚动</h4><p>在苹果系统上非<code>&lt;body&gt;</code>元素的滚动操作可能会存在卡顿，但安卓系统不会出现该情况。通过声明<code>overflow-scrolling:touch</code>调用系统原生滚动事件优化弹性滚动，增加页面滚动的流畅度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br><span class="line">.elem &#123;</span><br><span class="line">    overflow: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="禁止滚动传播"><a href="#禁止滚动传播" class="headerlink" title="禁止滚动传播"></a>禁止滚动传播</h4><p>与桌面端浏览器不一样，移动端浏览器有一个奇怪行为。当页面包含多个滚动区域时，滚完一个区域后若还存在滚动动量则会将这些剩余动量传播到下一个滚动区域，造成该区域也滚动起来。这种行为称为<code>「滚动传播」</code>。</p><p>若不想产生这种奇怪行为可直接禁止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.elem &#123;</span><br><span class="line">    overscroll-behavior: contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="禁止屏幕抖动"><a href="#禁止屏幕抖动" class="headerlink" title="禁止屏幕抖动"></a>禁止屏幕抖动</h4><p>对于一些突然出现滚动条的页面，可能会产生左右抖动的不良影响。在一个滚动容器里，打开弹窗就隐藏滚动条，关闭弹窗就显示滚动条，来回操作会让屏幕抖动起来。提前声明滚动容器的padding-right为滚动条宽度，就能有效消除这个不良影响。</p><p>每个移动端浏览器的滚动条宽度都有可能不一致，甚至不一定占位置，通过以下方式能间接计算出滚动条的宽度。100vw为视窗宽度，100%为滚动容器内容宽度，相减就是滚动条宽度，妥妥的动态计算。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    padding-right: calc(100vw - 100%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="禁止长按操作"><a href="#禁止长按操作" class="headerlink" title="禁止长按操作"></a>禁止长按操作</h4><p>有时不想用户长按元素呼出菜单进行点链接、打电话、发邮件、保存图片或扫描二维码等操作，声明<code>touch-callout:none</code>禁止用户长按操作。</p><p>有时不想用户复制粘贴盗文案，声明<code>user-select:none</code>禁止用户长按操作和选择复制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    /* pointer-events: none; */ /* 微信浏览器还需附加该属性才有效 */</span><br><span class="line">    user-select: none; /* 禁止长按选择文字 */</span><br><span class="line">    -webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但声明user-select:none会让<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>无法输入文本，可对其声明<code>user-select:auto</code>排除在外。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input,</span><br><span class="line">textarea &#123;</span><br><span class="line">    user-select: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="禁止字体调整"><a href="#禁止字体调整" class="headerlink" title="禁止字体调整"></a>禁止字体调整</h4><p>旋转屏幕可能会改变字体大小，声明text-size-adjust:100%让字体大小保持不变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    text-size-adjust: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="禁止高亮显示"><a href="#禁止高亮显示" class="headerlink" title="禁止高亮显示"></a>禁止高亮显示</h4><p>触摸元素会出现半透明灰色遮罩，不想要！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    -webkit-tap-highlight-color: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="禁止动画闪屏"><a href="#禁止动画闪屏" class="headerlink" title="禁止动画闪屏"></a>禁止动画闪屏</h4><p>在移动设备上添加动画，多数情况会出现闪屏，给动画元素的父元素构造一个3D环境就能让动画稳定运行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.elem &#123;</span><br><span class="line">    perspective: 1000;</span><br><span class="line">    backface-visibility: hidden;</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="美化表单外观"><a href="#美化表单外观" class="headerlink" title="美化表单外观"></a>美化表单外观</h4><p>表单元素样式太丑希望自定义，appearance:none来帮你。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button,</span><br><span class="line">input,</span><br><span class="line">select,</span><br><span class="line">textarea &#123;</span><br><span class="line">    appearance: none;</span><br><span class="line">    /* 自定义样式 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="美化滚动占位"><a href="#美化滚动占位" class="headerlink" title="美化滚动占位"></a>美化滚动占位</h4><p>滚动条样式太丑希望自定义，<code>::-webkit-scrollbar-*</code>来帮你。记住以下三个关键词就能随机应变了。</p><ul><li style="list-style: none"><input type="checkbox" checked> 「::-webkit-scrollbar」：滚动条整体部分</li><li style="list-style: none"><input type="checkbox" checked> 「::-webkit-scrollbar-track」：滚动条轨道部分</li><li style="list-style: none"><input type="checkbox" checked> 「::-webkit-scrollbar-thumb」：滚动条滑块部分</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">    width: 6px;</span><br><span class="line">    height: 6px;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    background-image: linear-gradient(135deg, <span class="comment">#09f, #3c9);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="美化输入占位"><a href="#美化输入占位" class="headerlink" title="美化输入占位"></a>美化输入占位</h4><p>输入框占位文本太丑，<code>::-webkit-input-placeholder</code>来帮你。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input::-webkit-input-placeholder &#123;</span><br><span class="line">    color: <span class="comment">#66f;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对齐输入占位"><a href="#对齐输入占位" class="headerlink" title="对齐输入占位"></a>对齐输入占位</h4><p>有强迫症的同学总会觉得输入框文本位置整体偏上，感觉未居中心里就痒痒的。桌面端浏览器里声明<code>line-height</code>等于<code>height</code>就能解决，但移动端浏览器里还是未能解决，需将<code>line-height</code>声明为<code>normal</code>才行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    line-height: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对齐下拉选项"><a href="#对齐下拉选项" class="headerlink" title="对齐下拉选项"></a>对齐下拉选项</h4><p>下拉框选项默认向左对齐，是时候改改向右对齐了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select option &#123;</span><br><span class="line">    direction: rtl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修复点击无效"><a href="#修复点击无效" class="headerlink" title="修复点击无效"></a>修复点击无效</h4><p>在苹果系统上有些情况下非可点击元素监听<code>click</code>事件可能会无效，针对该情况只需对不触发<code>click</code>事件的元素声明<code>cursor:pointer</code>就能解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.elem &#123;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="识别文本换行"><a href="#识别文本换行" class="headerlink" title="识别文本换行"></a>识别文本换行</h4><p>多数情况会使用<code>JS</code>换行文本，那就真的<code>Out</code>了。若接口返回字段包含<code>\n</code>或<code>&lt;br&gt;</code>，千万别替换掉，可声明<code>white-space:pre-line</code>交由浏览器做断行处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    white-space: pre-line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开启硬件加速"><a href="#开启硬件加速" class="headerlink" title="开启硬件加速"></a>开启硬件加速</h4><p>想动画更流畅吗，开启GPU硬件加速呗！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.elem &#123;</span><br><span class="line">    transform: translate3d(0, 0, 0);</span><br><span class="line">    /* transform: translateZ(0); */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="描绘像素边框"><a href="#描绘像素边框" class="headerlink" title="描绘像素边框"></a>描绘像素边框</h4><p>万年话题，如何描绘一像素边框？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.elem &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 80px;</span><br><span class="line">    &amp;::after &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        border: 1px solid <span class="comment">#f66;</span></span><br><span class="line">        width: 200%;</span><br><span class="line">        height: 200%;</span><br><span class="line">        content: <span class="string">""</span>;</span><br><span class="line">        transform: scale(.5);</span><br><span class="line">        transform-origin: left top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制溢出文本"><a href="#控制溢出文本" class="headerlink" title="控制溢出文本"></a>控制溢出文本</h4><p>万年话题，如何控制文本做单行溢出和多行溢出？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.elem &#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    line-height: 30px;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">    &amp;.sl-ellipsis &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        text-overflow: ellipsis;</span><br><span class="line">        white-space: nowrap;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;.ml-ellipsis &#123;</span><br><span class="line">        display: -webkit-box;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        text-overflow: ellipsis;</span><br><span class="line">        -webkit-line-clamp: 3;</span><br><span class="line">        -webkit-box-orient: vertical;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js方向"><a href="#js方向" class="headerlink" title="js方向"></a>js方向</h2><h4 id="支持往返刷新"><a href="#支持往返刷新" class="headerlink" title="支持往返刷新"></a>支持往返刷新</h4><p>点击移动端浏览器的前进按钮或后退按钮，有时不会自动执行旧页面的JS代码，这与往返缓存有关。这种情况在<code>Safari</code>上特别明显，简单概括就是往返页面无法刷新。<br><code>pageshow</code>事件在每次页面加载时都会触发，无论是首次加载还是再次加载都会触发，这就是它与<code>load</code>事件的区别。<code>pageshow</code>事件暴露的<code>persisted</code>可判断页面是否从<code>BFCache</code>里取出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">"pageshow"</span>, e =&gt; e.persisted &amp;&amp; location.reload());</span><br></pre></td></tr></table></figure><h4 id="简化回到顶部"><a href="#简化回到顶部" class="headerlink" title="简化回到顶部"></a>简化回到顶部</h4><p>曾几何时编写一个返回顶部函数麻烦得要死，需<code>scrollTop</code>、<code>定时器</code>和<code>条件判断</code>三者配合才能完成。其实<code>DOM</code>对象里隐藏了一个很好用的函数可完成上述功能，一行核心代码就能搞定。</p><p>该函数就是<code>scrollIntoView</code>，它会滚动目标元素的父容器使之对用户可见，简单概括就是相对视窗让容器滚动到目标元素位置。它有三个可选参数能让<code>scrollIntoView</code>滚动起来更优雅。</p><ul><li style="list-style: none"><input type="checkbox" checked> <code>「behavior」</code>：动画过渡效果，默认<code>auto</code>无，可选<code>smooth</code>平滑</li><li style="list-style: none"><input type="checkbox" checked> <code>「inline」</code>：水平方向对齐方式，默认<code>nearest</code>就近对齐，可选<code>start</code>顶部对齐、<code>center</code>中间对齐和<code>end</code>底部对齐</li><li style="list-style: none"><input type="checkbox" checked> <code>「block」</code>：垂直方向对齐方式，默认<code>start</code>顶部对齐，可选<code>center</code>中间对齐、<code>end</code>底部对齐和<code>nearest</code>就近对齐</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const gotopBtn = document.getElementById(<span class="string">"gotop-btn"</span>);</span><br><span class="line">openBtn.addEventListener(<span class="string">"click"</span>, () =&gt; document.body.scrollIntoView(&#123; behavior: <span class="string">"smooth"</span> &#125;));</span><br></pre></td></tr></table></figure><h4 id="简化懒性加载"><a href="#简化懒性加载" class="headerlink" title="简化懒性加载"></a>简化懒性加载</h4><p>与上述「简化回到顶部」一样，编写一个懒性加载函数也同样需<code>scrollTop</code>、定时器和条件判断三者配合才能完成。其实<code>DOM</code>对象里隐藏了一个很好用的函数可完成上述功能，该函数无需监听容器的<code>scroll</code>事件，通过浏览器自身机制完成滚动监听。</p><p>该函数就是<code>IntersectionObserver</code>，它提供一种异步观察目标元素及其祖先元素或顶级文档视窗交叉状态的方法。详情可参照MDN文档，在此不作过多介绍。</p><p>懒性加载的第一种使用场景：<code>「图片懒加载」</code>。只需确认图片进入可视区域就赋值加载图片，赋值完成还需对图片停止监听。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const imgs = document.querySelectorAll(<span class="string">"img.lazyload"</span>);</span><br><span class="line">const observer = new IntersectionObserver(nodes =&gt; &#123;</span><br><span class="line">    nodes.forEach(v =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (v.isIntersecting) &#123; // 判断是否进入可视区域</span><br><span class="line">            v.target.src = v.target.dataset.src; // 赋值加载图片</span><br><span class="line">            observer.unobserve(v.target); // 停止监听已加载的图片</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">imgs.forEach(v =&gt; observer.observe(v));</span><br></pre></td></tr></table></figure><p>懒性加载的第二种使用场景：「下拉加载」。在列表最底部部署一个占位元素且该元素无任何高度或实体外观，只需确认占位元素进入可视区域就请求接口加载数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;!-- 很多&lt;li&gt; --&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;!-- 也可将<span class="comment">#bottom以&lt;li&gt;的形式插入到&lt;ul&gt;内部的最后位置 --&gt;</span></span><br><span class="line">&lt;div id=<span class="string">"bottom"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">const bottom = document.getElementById(<span class="string">"bottom"</span>);</span><br><span class="line">const observer = new IntersectionObserver(nodes =&gt; &#123;</span><br><span class="line">    const tgt = nodes[0]; // 反正只有一个</span><br><span class="line">    <span class="keyword">if</span> (tgt.isIntersecting) &#123;</span><br><span class="line">        console.log(<span class="string">"已到底部，请求接口"</span>);</span><br><span class="line">        // 执行接口请求代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">bottom.observe(bottom);</span><br></pre></td></tr></table></figure><h4 id="优化扫码识别"><a href="#优化扫码识别" class="headerlink" title="优化扫码识别"></a>优化扫码识别</h4><p>通常移动端浏览器都会配备长按二维码图片识别链接的功能，但长按二维码可能无法识别或错误识别。二维码表面看上去是一张图片，可二维码生成方式却五花八门，二维码生成方式有以下三种。</p><ul><li style="list-style: none"><input type="checkbox" checked> 使用<code>&lt;img&gt;</code>渲染</li><li style="list-style: none"><input type="checkbox" checked> 使用<code>&lt;svg&gt;</code>渲染</li><li style="list-style: none"><input type="checkbox" checked> 使用<code>&lt;canvas&gt;</code>渲染</li></ul><p>从网易MTL的测试数据得知，大部分移动端浏览器只能识别<code>&lt;img&gt;</code>渲染的二维码，为了让全部移动端浏览器都能识别二维码，那只能使用<code>&lt;img&gt;</code>渲染二维码了。若使用<code>SVG和Canvas</code>的方式生成二维码，那就想方设法把二维码数据转换成Base64再赋值到<code>&lt;img&gt;</code>的<code>src</code>上。</p><p>一个页面可能存在多个二维码，若长按二维码只能识别最后一个，那只能控制每个页面只存在一个二维码。</p><h5 id="文章转自-作者JowayYoung-https-mp-weixin-qq-com-s-nge9FPgVS6FZcuVOTxCBtQ"><a href="#文章转自-作者JowayYoung-https-mp-weixin-qq-com-s-nge9FPgVS6FZcuVOTxCBtQ" class="headerlink" title="文章转自 作者JowayYoung https://mp.weixin.qq.com/s/nge9FPgVS6FZcuVOTxCBtQ"></a>文章转自 作者JowayYoung <a href="https://mp.weixin.qq.com/s/nge9FPgVS6FZcuVOTxCBtQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nge9FPgVS6FZcuVOTxCBtQ</a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;移动端开发在前端里像神一样地存在，不是说它多难而是说它坑位实在太多了，怎样填都填不完。Android和iOS各显神通，Android的系统版本和屏幕分辨率多得难以一招兼容，iOS的顽固标准和未知特性多得难以快速掌握。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;三年</summary>
      
    
    
    
    <category term="前端" scheme="https://gofugui.github.io/categories/前端/"/>
    
    
    <category term="JavaScript" scheme="https://gofugui.github.io/tags/JavaScript/"/>
    
    <category term="Web" scheme="https://gofugui.github.io/tags/Web/"/>
    
    <category term="ES6" scheme="https://gofugui.github.io/tags/ES6/"/>
    
    <category term="html" scheme="https://gofugui.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>react-native-code-push 热更新配置</title>
    <link href="https://gofugui.github.io/2019/11/12/code-push/"/>
    <id>https://gofugui.github.io/2019/11/12/code-push/</id>
    <published>2019-11-11T16:00:00.000Z</published>
    <updated>2021-03-31T05:56:45.778Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>公司主打的一款新项目，为了满足快速迭代的需要，使用rn进行开发，项目中使用到了微软的code-push热更新功能，在这里记录一下热更新的集成过程，以及注意点。</p></blockquote><h3 id="react-native-热更新需要用到的工具"><a href="#react-native-热更新需要用到的工具" class="headerlink" title="react-native 热更新需要用到的工具"></a>react-native 热更新需要用到的工具</h3><ul><li><p>mysql,node </p></li><li><p><a href="https://github.com/gofugui/react-native-code-push" target="_blank" rel="noopener">react-native-code-push</a></p></li><li><p><a href="https://github.com/gofugui/code-push-server" target="_blank" rel="noopener">code-push-server</a></p></li></ul><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><h4 id="code-push-server"><a href="#code-push-server" class="headerlink" title="code-push-server"></a>code-push-server</h4><ul><li>步骤一</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装code-push-server</span></span><br><span class="line">npm install -g code-push-server</span><br><span class="line"><span class="comment">#进入到code-push-server目录，</span></span><br><span class="line"><span class="built_in">cd</span> &lt;YOUR_DIR&gt;/code-push-server/config</span><br><span class="line"><span class="comment">#打开config/config.js文件</span></span><br><span class="line">vi config.js</span><br><span class="line"><span class="comment">#配置数据库(以下是默认的，数据库的用户名、密码、地址还有端口需要修改成你自己的)</span></span><br><span class="line"> db: &#123;</span><br><span class="line">    username: process.env.RDS_USERNAME || <span class="string">"root"</span>,</span><br><span class="line">    password: process.env.RDS_PASSWORD || null,</span><br><span class="line">    database: process.env.DATA_BASE || <span class="string">"codepush"</span>,</span><br><span class="line">    host: process.env.RDS_HOST || <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    port: process.env.RDS_PORT || 3306,</span><br><span class="line">    dialect: <span class="string">"mysql"</span>,</span><br><span class="line">    logging: <span class="literal">false</span>,</span><br><span class="line">    operatorsAliases: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置下载文件的存储地址，你可以选择一些云oss存储服务</span></span><br><span class="line"><span class="comment">#此处我们将数据存储在服务器本地</span></span><br><span class="line"><span class="comment">#配置storageDir为你的电脑上的目录</span></span><br><span class="line"><span class="comment">#配置downloadUrl为你的服务器的下载地址</span></span><br><span class="line"><span class="built_in">local</span>: &#123;</span><br><span class="line">    <span class="comment"># Binary files storage dir, Do not use tmpdir and it's public download dir.</span></span><br><span class="line">    storageDir: process.env.STORAGE_DIR || <span class="string">"/Users/tablee/workspaces/storage"</span>,</span><br><span class="line">    <span class="comment"># Binary files download host address which Code Push Server listen to. the files storage in storageDir.</span></span><br><span class="line">    downloadUrl: process.env.LOCAL_DOWNLOAD_URL || <span class="string">"http://127.0.0.1:3000/download"</span>,</span><br><span class="line">    <span class="comment"># public static download spacename.</span></span><br><span class="line">    public: <span class="string">'/download'</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">#配置增量文件的存储地址</span></span><br><span class="line"><span class="comment">#修改dataDir为你的本地路径</span></span><br><span class="line">common: &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data dir for caclulate diff files. it's optimization.</span></span><br><span class="line">    dataDir: process.env.DATA_DIR || os.tmpdir(),</span><br><span class="line">    <span class="comment"># storageType which is your binary package files store. options value is ("local" | "qiniu" | "s3"| "oss" || "tencentcloud")</span></span><br><span class="line">    storageType: process.env.STORAGE_TYPE || <span class="string">"local"</span>,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ul><li>步骤二<blockquote><p>安装CodePush CLI，用以和code-push-server服务进行交互,相关的code-push指令可以查看我之前的文章<a href="https://gofugui.github.io/2019/03/07/code-push-command">code-push-command</a></p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装CodePush CLI</span></span><br><span class="line">npm install -g code-push-cli</span><br></pre></td></tr></table></figure><h4 id="react-native-code-push"><a href="#react-native-code-push" class="headerlink" title="react-native-code-push"></a>react-native-code-push</h4><blockquote><p>到这一步时首先确保你已经将你的app添加进了<code>code-push-server</code>，如果还没有，请查看<a href="https://gofugui.github.io/2019/03/07/code-push-command">code-push-command</a>里的讲解，添加app到<code>code-push-server</code>，并获取<code>Deployment Key</code></p></blockquote><ul><li>步骤一</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line">npm install --save react-native-code-push</span><br><span class="line"><span class="comment">#链接原生库</span></span><br><span class="line">react-native link react-native-code-push</span><br></pre></td></tr></table></figure><ul><li>步骤二</li></ul><blockquote><p>在完成<a href="#步骤一">步骤一</a>的操作后，会自动在Android和iOS的源码中插入一些代码，引用这个库，但是我们还需要在这个基础上做一些个性化的配置。下面介绍一下针对不同平台的配置方法。</p></blockquote><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><h5 id="配置Android端的Deployment-Key"><a href="#配置Android端的Deployment-Key" class="headerlink" title="配置Android端的Deployment Key"></a>配置Android端的Deployment Key</h5><blockquote><p>为以后维护方便，我们将key值存放在Android目录下<code>gradle.properties</code>中：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># When configured, Gradle will run in incubating parallel mode.</span></span><br><span class="line"><span class="comment"># This option should only be used with decoupled projects. More details, visit</span></span><br><span class="line"><span class="comment"># http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">RELEASE_STAGING=&lt;YOUR_RELEASE_STAGING_KEY&gt;</span><br><span class="line">RELEASE = &lt;YOUR_RELEASE_KEY&gt;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h5 id="修改build-gradle中的配置，以便打不同测试类型的包"><a href="#修改build-gradle中的配置，以便打不同测试类型的包" class="headerlink" title="修改build.gradle中的配置，以便打不同测试类型的包"></a>修改build.gradle中的配置，以便打不同测试类型的包</h5><blockquote><p>为了在测试机上同时安装测试版和预发布版的app包，我们需要在<code>Android/app/build.gradle</code>中配置对应包的applicationId后缀，在buildTypes下修改如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    <span class="comment"># 开发版的包 没有配置热更新，所以CODEPUSH_KEY的值为空</span></span><br><span class="line">    <span class="comment"># 打包方法 react-native run-android --variant=debug --appIdSuffix=debug</span></span><br><span class="line">    debug &#123;</span><br><span class="line"></span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"CODEPUSH_KEY"</span>, <span class="string">'""'</span></span><br><span class="line">        minifyEnabled enableProguardInReleaseBuilds</span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">"proguard-android.txt"</span>), <span class="string">"proguard-rules.pro"</span></span><br><span class="line">        applicationIdSuffix <span class="string">".debug"</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 灰度测试版本的包 CODEPUSH_KEY为我们之前在gradle.properties中的 RELEASE_STAGING 值</span></span><br><span class="line">    <span class="comment"># 打包方法 react-native run-android --variant=staging --appIdSuffix=staging</span></span><br><span class="line">    staging &#123;</span><br><span class="line"></span><br><span class="line">        matchingFallbacks = [<span class="string">'release'</span>, <span class="string">'debug'</span>]</span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"CODEPUSH_KEY"</span>, RELEASE_STAGING</span><br><span class="line">        applicationIdSuffix <span class="string">".staging"</span></span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line">        minifyEnabled enableProguardInReleaseBuilds</span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">"proguard-android.txt"</span>), <span class="string">"proguard-rules.pro"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#正式版的包 CODEPUSH_KEY为我们之前在gradle.properties中的 RELEASE 值</span></span><br><span class="line">    release &#123;</span><br><span class="line">        </span><br><span class="line">        debuggable <span class="literal">false</span> // 是否debug</span><br><span class="line">        aaptOptions.cruncherEnabled = <span class="literal">false</span> // 禁止Gradle检查PNG的合法性</span><br><span class="line">        buildConfigField <span class="string">"String"</span>, <span class="string">"CODEPUSH_KEY"</span>, RELEASE</span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line">        minifyEnabled enableProguardInReleaseBuilds</span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">"proguard-android.txt"</span>), <span class="string">"proguard-rules.pro"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在MainApplication中修改如下代码"><a href="#在MainApplication中修改如下代码" class="headerlink" title="在MainApplication中修改如下代码"></a>在<code>MainApplication</code>中修改如下代码</h5><blockquote><p><code>YOUR_SERVER_URL</code>为热更新服务器的地址，通过改地址可以访问到你的code-push-server服务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new CodePush(BuildConfig.CODEPUSH_KEY, getApplicationContext(), BuildConfig.DEBUG,&lt;YOUR_SERVER_URL&gt;),</span><br></pre></td></tr></table></figure><h4 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h4><blockquote><p>与在android上的配置相似，我们同样要给iOS配置三个版本的包名：<code>debug、staging(beta)、release</code>。项目初始化时已经存在<code>debug</code>和<code>release</code>版本，所以我们只需要添加<code>staging</code>类型</p></blockquote><h5 id="添加灰度测试版本staging"><a href="#添加灰度测试版本staging" class="headerlink" title="添加灰度测试版本staging"></a>添加灰度测试版本staging</h5><ol><li>在项目的<code>PROJECT-Info</code>的<code>Configurations</code>里面点击<code>+</code>选择<code>Duplicate &quot;Release&quot; Configuration</code>, 并且给一个名字，我这里给了个Staging，如图：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/2419788-5d1006e95d983101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="添加staging"></p><ol start="2"><li><p>在<code>PROJECT-Build setting-Per-configuration Build Products path-Staging</code>里面改成<code>$(BUILD_DIR)/Release$(EFFECTIVE_PLATFORM_NAME)</code></p></li><li><p>然后在项目的<code>PROJECT-Build Setting</code>里面点击<code>+</code>选择<code>Add User-Defined Setting</code>，创建好之后起个名字，这里叫<code>CODEPUSH_KEY</code>, 然后在<code>Release</code>和<code>Staging</code>里面分别写上code-push-server中添加的项目后生成的Production和Staging对应的key值,如图：</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/2419788-a165590ecb7d474f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="添加key值"></p><h5 id="给项目名称添加后缀"><a href="#给项目名称添加后缀" class="headerlink" title="给项目名称添加后缀"></a>给项目名称添加后缀</h5><blockquote><p>为了使项目在打包后方便区分打包的类型，我们可以在项目名称后面加上对应的后缀：</p></blockquote><ol><li>然后在项目的<code>PROJECT-Build Setting</code>里面点击<code>+</code>选择<code>Add User-Defined Setting</code>，创建好之后起个名字，这里叫<code>BUNDLE_DISPLAY_NAME_SUFFIX</code>, 然后在<code>Debug</code>后面写上<code>-Debug</code>,在<code>Staging</code>后面写上<code>-Beta</code>,如图：</li></ol><p><img src="https://github.com/gofugui/hexo/blob/master/source/images/4B1D1B79-8D21-48E2-BFEF-254EC365BED6.png?raw=true" alt="后缀"></p><ol start="2"><li>在Info.plist里面加上刚才配置好的后缀，如图：</li></ol><p><img src="https://github.com/gofugui/hexo/blob/master/source/images/32B48110-9016-48AC-9598-14FF3FAB6E6A.png?raw=true" alt="Info.plist配置"></p><h3 id="在react-native端配置更新的应用时机"><a href="#在react-native端配置更新的应用时机" class="headerlink" title="在react-native端配置更新的应用时机"></a>在react-native端配置更新的应用时机</h3><ul><li>Silent sync on app start (the simplest, default behavior)</li></ul><blockquote><p>这种方式会自动从服务器下载可用的更新，并且在应用下次启动的时候应用更新，整个过程用户是无感知的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fully silent update which keeps the app in</span></span><br><span class="line"><span class="comment"># sync with the server, without ever</span></span><br><span class="line"><span class="comment"># interrupting the end user</span></span><br><span class="line">class MyApp extends Component&lt;&#123;&#125;&gt; &#123;&#125;</span><br><span class="line">MyApp = codePush(MyApp);</span><br><span class="line"><span class="built_in">export</span> default MyApp;</span><br></pre></td></tr></table></figure><ul><li>Silent sync everytime the app resumes</li></ul><blockquote><p>当应用进入后台时，会从服务器检测是否有可用的更新，并下载更新，当应用再次从后台被唤醒的时候应用更新</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sync for updates everytime the app resumes.</span></span><br><span class="line">class MyApp extends Component&lt;&#123;&#125;&gt; &#123;&#125;</span><br><span class="line">MyApp = codePush(&#123; checkFrequency: codePush.CheckFrequency.ON_APP_RESUME, installMode: codePush.InstallMode.ON_NEXT_RESUME &#125;)(MyApp);</span><br><span class="line"><span class="built_in">export</span> default MyApp;</span><br></pre></td></tr></table></figure><ul><li>Interactive</li></ul><blockquote><p>交互式更新。只有当用户进行选择检查更新并确认后才下载和立即应用更新包</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Active update, which lets the end user know</span></span><br><span class="line"><span class="comment"># about each update, and displays it to them</span></span><br><span class="line"><span class="comment"># immediately after downloading it</span></span><br><span class="line">class MyApp extends Component&lt;&#123;&#125;&gt; &#123;&#125;</span><br><span class="line">MyApp = codePush(&#123; updateDialog: <span class="literal">true</span>, installMode: codePush.InstallMode.IMMEDIATE &#125;)(MyApp);</span><br><span class="line"><span class="built_in">export</span> default MyApp;</span><br></pre></td></tr></table></figure><ul><li>Log/display progress</li></ul><blockquote><p>显示更新的进度，我们可以通过如下的方法</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make use of the event hooks to keep track of</span></span><br><span class="line"><span class="comment"># the different stages of the sync process.</span></span><br><span class="line">class MyApp extends Component&lt;&#123;&#125;&gt; &#123;</span><br><span class="line">    codePushStatusDidChange(status) &#123;</span><br><span class="line">        switch(status) &#123;</span><br><span class="line">            <span class="keyword">case</span> codePush.SyncStatus.CHECKING_FOR_UPDATE:</span><br><span class="line">                console.log(<span class="string">"Checking for updates."</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> codePush.SyncStatus.DOWNLOADING_PACKAGE:</span><br><span class="line">                console.log(<span class="string">"Downloading package."</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> codePush.SyncStatus.INSTALLING_UPDATE:</span><br><span class="line">                console.log(<span class="string">"Installing update."</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> codePush.SyncStatus.UP_TO_DATE:</span><br><span class="line">                console.log(<span class="string">"Up-to-date."</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> codePush.SyncStatus.UPDATE_INSTALLED:</span><br><span class="line">                console.log(<span class="string">"Update installed."</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codePushDownloadDidProgress(progress) &#123;</span><br><span class="line">        console.log(progress.receivedBytes + <span class="string">" of "</span> + progress.totalBytes + <span class="string">" received."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyApp = codePush(MyApp);</span><br><span class="line"><span class="built_in">export</span> default MyApp;</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="1-react-native-code-push热更新与app版本的关系"><a href="#1-react-native-code-push热更新与app版本的关系" class="headerlink" title="1.react-native-code-push热更新与app版本的关系"></a>1.react-native-code-push热更新与app版本的关系</h4><ul><li>android</li></ul><blockquote><p>android在code-push发布更新的时候，版本独立不影响的位数是<code>两位数</code>。</p></blockquote><p>  举例说明：</p><blockquote><p>  a. versionName为2.1，和versionName为2.2的两个app版本,当versionName=2.2的app发布codepush更新的时候，受影响的只有2.2 和2.2.X，X为正整数。versionName=2.1是不会收到任何影响的，所以后续就需要创建两条线路对不同的版本进行维护。</p></blockquote><blockquote><p>   b. 由a可以知道，versionName=2.2.1和versionName=2.2.2两个版本在获取更新上，获取的是同个版本,当versionName=2.2.2发布更新的时候，versionName=2.2.1的app同样会受到影响接受更新。</p></blockquote><blockquote><p>总结：从以上特性，我们主要将这个功能用在小版本更新，或者bug修复上。versionName = X.Y.Z的版本中，我们主要发布到应用市场的软件一般都是改变：X.Y的值。对于创业公司来说，要维护多个软件版本成本是非常高的，所以我们也是尽量要求用户升级到最新版本。</p></blockquote><ul><li>ios</li></ul><blockquote><p>IOS在codepush发布更新时，版本独立不影响的位数是<code>三位数</code>。即iOS版本都是独立不影响，version=X.Y.Z，当codepush发布更新时，只会影响与其X.Y.Z三位数完全相同的版本。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;公司主打的一款新项目，为了满足快速迭代的需要，使用rn进行开发，项目中使用到了微软的code-push热更新功能，在这里记录一下热更新的集成过程，以及注意点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;react-native-热更新需要</summary>
      
    
    
    
    <category term="code-push 热更新构建说明" scheme="https://gofugui.github.io/categories/code-push-热更新构建说明/"/>
    
    
    <category term="热更新" scheme="https://gofugui.github.io/tags/热更新/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令速查表</title>
    <link href="https://gofugui.github.io/2019/11/10/Git-doc/"/>
    <id>https://gofugui.github.io/2019/11/10/Git-doc/</id>
    <published>2019-11-09T16:00:00.000Z</published>
    <updated>2021-04-19T02:18:32.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-常用术语"><a href="#git-常用术语" class="headerlink" title="git 常用术语"></a>git 常用术语</h3><ul><li>master        默认开发分支</li><li>origin        默认远程版本库</li><li>Index/Stage   暂存区</li><li>Workspace     工作区</li><li>Repository    仓库区（或本地仓库）</li><li>Remote        远程仓库</li></ul><h3 id="git-创建代码库"><a href="#git-创建代码库" class="headerlink" title="git 创建代码库"></a>git 创建代码库</h3><h4 id="在当前目录新建一个git代码库"><a href="#在当前目录新建一个git代码库" class="headerlink" title="在当前目录新建一个git代码库"></a>在当前目录新建一个git代码库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git init </span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">"first commit"</span></span><br><span class="line"><span class="comment"># 链接远程仓库</span></span><br><span class="line">$ git remote add origin 【远程仓库地址】</span><br><span class="line">$ git push -u origin master</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h4 id="已有本地仓，链接远程仓库"><a href="#已有本地仓，链接远程仓库" class="headerlink" title="已有本地仓，链接远程仓库"></a>已有本地仓，链接远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin 【远程仓库地址】</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><h4 id="指定一个目录，将其初始化为git代码库"><a href="#指定一个目录，将其初始化为git代码库" class="headerlink" title="指定一个目录，将其初始化为git代码库"></a>指定一个目录，将其初始化为git代码库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init [project-name]</span><br></pre></td></tr></table></figure><h4 id="下载一个项目和它的整个代码历史"><a href="#下载一个项目和它的整个代码历史" class="headerlink" title="下载一个项目和它的整个代码历史"></a>下载一个项目和它的整个代码历史</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h4 id="下载一个项目和他最近一次的提交-当要克隆的项目过大，出现TimeOut问题时谨慎使用"><a href="#下载一个项目和他最近一次的提交-当要克隆的项目过大，出现TimeOut问题时谨慎使用" class="headerlink" title="下载一个项目和他最近一次的提交(当要克隆的项目过大，出现TimeOut问题时谨慎使用 )"></a>下载一个项目和他最近一次的提交(当要克隆的项目过大，出现TimeOut问题时谨慎使用 )</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --depth 1 [url]</span><br></pre></td></tr></table></figure><blockquote><p>这种方法克隆的项目只包含最近commit的一个分支，体积很小，但会产生另外一个问题，他只会把默认分支clone下来，其他远程分支并不在本地，所以这种情况下，需要用如下方法拉取其他分支：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-branches origin [remote_branch_name]</span><br><span class="line">$ git fetch --depth 1 origin [remote_branch_name]</span><br><span class="line">$ git checkout [remote_branch_name]</span><br></pre></td></tr></table></figure><h3 id="git-配置信息"><a href="#git-配置信息" class="headerlink" title="git 配置信息"></a>git 配置信息</h3><blockquote><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p></blockquote><h4 id="显示当前的git配置信息"><a href="#显示当前的git配置信息" class="headerlink" title="显示当前的git配置信息"></a>显示当前的git配置信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><h4 id="编辑git配置文件"><a href="#编辑git配置文件" class="headerlink" title="编辑git配置文件"></a>编辑git配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e [--global]</span><br></pre></td></tr></table></figure><h4 id="设置提交代码的用户信息"><a href="#设置提交代码的用户信息" class="headerlink" title="设置提交代码的用户信息"></a>设置提交代码的用户信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config [--global] user.name  <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure><h3 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h3><h4 id="增加、删除、修改文件"><a href="#增加、删除、修改文件" class="headerlink" title="增加、删除、修改文件"></a>增加、删除、修改文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看分支下文件状态</span></span><br><span class="line">$ git status   </span><br><span class="line"><span class="comment">#查看变更内容 </span></span><br><span class="line">$ git diff      </span><br><span class="line"><span class="comment">#添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ... </span><br><span class="line"><span class="comment">#添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir] </span><br><span class="line"><span class="comment">#添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .     </span><br><span class="line"><span class="comment">#添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment">#对于同一个文件的多次变化，可以实现分次提交</span></span><br><span class="line">$ git add -p    </span><br><span class="line"><span class="comment">#删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"><span class="comment">#停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file] </span><br><span class="line"><span class="comment">#强制停止</span></span><br><span class="line">$ git rm -f --cached [file]</span><br><span class="line"><span class="comment">#更改文件名，并将改名放入暂存区</span></span><br><span class="line">$ git mv [file-originName] [file-newName]</span><br></pre></td></tr></table></figure><h4 id="git-代码提交"><a href="#git-代码提交" class="headerlink" title="git 代码提交"></a>git 代码提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提交暂存区到仓库</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"><span class="comment">#提交暂存区指定文件到仓库</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"><span class="comment">#提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"><span class="comment">#提交提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"><span class="comment">#使用一次新的commit，代替上次提交</span></span><br><span class="line"><span class="comment">#如果代码没有任何变化，则用来改写上一次的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"><span class="comment">#使用一次新的commit，指定文件，代替上次提交</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h4 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示所有分支</span></span><br><span class="line">$ git branch</span><br><span class="line"><span class="comment">#列出所有分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"><span class="comment">#列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"><span class="comment">#新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"><span class="comment">#新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-beanch]</span><br><span class="line"><span class="comment">#删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"><span class="comment">#删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote-branch]</span><br><span class="line"><span class="comment">#新建一个分支并切换到这个分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"><span class="comment">#基于现有分支创建一个分支</span></span><br><span class="line">$ git checkout -b [new-branch] [origin-branch]</span><br><span class="line"><span class="comment">#切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"><span class="comment">#切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"><span class="comment">#建立追踪关系，在现有分支到远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"><span class="comment">#合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"><span class="comment">#衍合并指定分支到当前分支</span></span><br><span class="line">$ git rebase &lt;branch&gt;</span><br><span class="line"><span class="comment">#选择一个commit合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br></pre></td></tr></table></figure><h3 id="git-标签"><a href="#git-标签" class="headerlink" title="git 标签"></a>git 标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出所有本地标签</span></span><br><span class="line">$ git tag</span><br><span class="line"><span class="comment">#基于最新提交创建标签</span></span><br><span class="line">$ git tag &lt;tagname&gt;</span><br><span class="line"><span class="comment">#删除标签</span></span><br><span class="line">$ git tag -d &lt;tagname&gt;</span><br><span class="line"><span class="comment">#删除远程标签</span></span><br><span class="line">$ git push origin :refs/tags/[tagname]</span><br><span class="line"><span class="comment">#查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"><span class="comment">#提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"><span class="comment">#提交所有tag</span></span><br><span class="line">$ git push [remote] --tag</span><br><span class="line"><span class="comment">#新建一个分支，指向某个tag </span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="git-查看信息"><a href="#git-查看信息" class="headerlink" title="git 查看信息"></a>git 查看信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有文件的变更信息</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment">#显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment">#显示commit历史，以及每次commit变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"><span class="comment">#搜索提交历史，根据关键字</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"><span class="comment">#显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"><span class="comment">#显示某个commit之后的所有变动，每个commit的‘提交信息’必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"><span class="comment">#显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --fellow [file]</span><br><span class="line">$ git whatchchange [file]</span><br><span class="line"><span class="comment">#显示文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"><span class="comment">#显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --online</span><br><span class="line"><span class="comment">#显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"><span class="comment">#显示文件是在什么时候被什么人修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"><span class="comment">#显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"><span class="comment">#显示暂存区和上一次commit之间的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"><span class="comment">#显示工作区与与当前分支最新一次commit的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"><span class="comment">#显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"><span class="comment">#显示了今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstart <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"><span class="comment">#显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"><span class="comment">#显示某次提交内容发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"><span class="comment">#显示提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"><span class="comment">#显示当前分支的最近几次提交的内容</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="git远程操作"><a href="#git远程操作" class="headerlink" title="git远程操作"></a>git远程操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"><span class="comment">#取回远程仓库的变化，并与本地仓库合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"><span class="comment">#显示所有的远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment">#显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"><span class="comment">#新增某个远程仓库，并命名</span></span><br><span class="line">$ git remote add [short-name] [url]</span><br><span class="line"><span class="comment">#上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"><span class="comment">#强行推送当前分支到指定仓库</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"><span class="comment">#推送所有分支到指定仓库</span></span><br><span class="line">$ git push [remote] --all</span><br><span class="line"><span class="comment">#上传远程分支和标签</span></span><br><span class="line">$ git push &lt;remote&gt;:&lt;branch/tag-name&gt;</span><br><span class="line"><span class="comment">#上传所有标签</span></span><br><span class="line">$ git push --tag</span><br></pre></td></tr></table></figure><h3 id="git-撤销"><a href="#git-撤销" class="headerlink" title="git 撤销"></a>git 撤销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#撤销工作目录中，所有未提交文件的修改内容</span></span><br><span class="line">$ git reset --hard HEAD </span><br><span class="line"><span class="comment">#撤销指定文件的修改内容</span></span><br><span class="line">$ git checkout HEAD &lt;file&gt;</span><br><span class="line"><span class="comment">#撤销指定的提交</span></span><br><span class="line">$ git revert &lt;commit&gt;</span><br><span class="line"><span class="comment">#退回到之前1天的版本</span></span><br><span class="line">$ git <span class="built_in">log</span> --before=<span class="string">"1 days"</span></span><br><span class="line"><span class="comment">#恢复暂存区的文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"><span class="comment">#恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"><span class="comment">#恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"><span class="comment">#重置暂存区的指定文件，与上一次commit一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"><span class="comment">#重置暂存区和工作区，与上一次commit一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"><span class="comment">#!!!!!!谨慎使用reset，因为reset会清除掉指定commit之后的commit记录，通常revert更常用</span></span><br><span class="line"><span class="comment">#重置但前分支的指针为指定commit，同时重置暂存区，工作区不变</span></span><br><span class="line">$ git reset [commit] </span><br><span class="line"><span class="comment">#重置当前分支的HEAD为指定commit，同时重置工作区和暂存区，与指定的commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"><span class="comment">#重置当前分支的HEAD为指定commit，保持工作区和暂存区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"><span class="comment">#新建一个commit用来撤销指定commit</span></span><br><span class="line"><span class="comment">#后者的所有变化都将被抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"><span class="comment">#暂时将未提交的内容移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h3 id="git-其他"><a href="#git-其他" class="headerlink" title="git 其他"></a>git 其他</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure><p>参考链接: <a href="https://www.toutiao.com/a6591290718067622407/?iid=33109242783&amp;app=news_article&amp;is_hit_share_recommend=0&amp;tt_from=qzone&amp;utm_source=qzone&amp;utm_medium=toutiao_ios&amp;utm_campaign=client_share" target="_blank" rel="noopener">点我查看</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git-常用术语&quot;&gt;&lt;a href=&quot;#git-常用术语&quot; class=&quot;headerlink&quot; title=&quot;git 常用术语&quot;&gt;&lt;/a&gt;git 常用术语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;master        默认开发分支&lt;/li&gt;
&lt;li&gt;origin    </summary>
      
    
    
    
    <category term="代码管理" scheme="https://gofugui.github.io/categories/代码管理/"/>
    
    
    <category term="Git" scheme="https://gofugui.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>code-push-server 热更新常用命令速查表</title>
    <link href="https://gofugui.github.io/2019/11/07/code-push-command/"/>
    <id>https://gofugui.github.io/2019/11/07/code-push-command/</id>
    <published>2019-11-06T16:00:00.000Z</published>
    <updated>2024-07-07T07:37:48.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#登陆(指定服务器路径，不加URL表示在本地服务器登录)</span></span><br><span class="line">code-push login &lt;url&gt;</span><br><span class="line"><span class="comment">#注销</span></span><br><span class="line">code-push <span class="built_in">logout</span></span><br><span class="line"><span class="comment">#列出登陆的token</span></span><br><span class="line">code-push access-key ls </span><br><span class="line"><span class="comment">#删除某个 access-key</span></span><br><span class="line">code-push access-key rm &lt;accessKye&gt;</span><br></pre></td></tr></table></figure><h3 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在账号里面添加一个新的app platform -&gt;[android,ios]</span></span><br><span class="line">code-push app add &lt;appName&gt; &lt;platform&gt; react-native</span><br><span class="line"><span class="comment">#删除项目</span></span><br><span class="line">code-push app rm &lt;appName&gt;</span><br><span class="line"><span class="comment">#重命名项目</span></span><br><span class="line">code-push app rename &lt;appName&gt; &lt;newName&gt;</span><br><span class="line"><span class="comment">#ls 列出账号下面的所有项目</span></span><br><span class="line">code-push app list </span><br><span class="line"><span class="comment">#把项目的所有权转移到另外一个账号</span></span><br><span class="line">code-push app transfer &lt;appName&gt; &lt;newOwnerEmail&gt;</span><br><span class="line"><span class="comment">#查看创建的APP</span></span><br><span class="line">code-push app ls</span><br></pre></td></tr></table></figure><h3 id="部署管理"><a href="#部署管理" class="headerlink" title="部署管理"></a>部署管理</h3><blockquote><p>react native 热更新应该考虑的几点<br>1、react native包的组织形式 –（一个包还是对包进行拆分成业务包和基础包，热更新时只更新业务包，更新的方式：1、全量更新；2、增量更新，更新的时机：显式更新还是隐式更新）<br>2、移动端获取热更新服务器上的更新，并验证更新包的合法性<br>3、本地合并更新的部分<br>4、错误处理和异常回滚<br>从CodePush的角度来看，一个应用把一个或更多的东西简单命名分组称为“部署(环境)”。</p></blockquote><blockquote><p>如果你的App有Staging和Production环境其实已经满足了你的需求，然后你不需要做任何事情。不过，如果你需要alpha，dev等部署环境，那你可以简单的使用如下命令创建</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个新的部署环境</span></span><br><span class="line">code-push deployment add &lt;appName&gt; &lt;deploymentName&gt;</span><br><span class="line"><span class="comment">#删除部署环境</span></span><br><span class="line">code-push deployment rm &lt;appName&gt; &lt;deploymentName&gt;</span><br><span class="line"><span class="comment">#重命名部署环境</span></span><br><span class="line">code-push deployment rename &lt;appName&gt; &lt;deploymentName&gt; &lt;newDeploymentName&gt;</span><br><span class="line"><span class="comment">#查看特定应用包含的部署环境列表</span></span><br><span class="line"><span class="comment">#这将不仅显示部署环境列表，</span></span><br><span class="line"><span class="comment">#而且还有元数据（例如：强制性属性，描述）</span></span><br><span class="line"><span class="comment">#和最新版本的安装指标：</span></span><br><span class="line">code-push deployment ls &lt;appName&gt; [--displayKeys|-k]</span><br></pre></td></tr></table></figure><h3 id="版本已经上线进行热更新"><a href="#版本已经上线进行热更新" class="headerlink" title="版本已经上线进行热更新"></a>版本已经上线进行热更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#操作需要在项目根目录下进行</span></span><br><span class="line">code-push release-react &lt;appName&gt; &lt;platform&gt; -t 版本  -d 环境  --des 描述 -m <span class="literal">true</span> （强制更新）</span><br></pre></td></tr></table></figure><blockquote><p>其中参数-t为二进制(.ipa与apk)安装包的的版本；-d是要发布更新的环境分Production与Staging(默认为Staging)；–des为更新说明；-m 是强制更新,如果不填写这个时候用户可以忽略更新到个人中心进行更新。</p></blockquote><p><img src="https://cloud.githubusercontent.com/assets/116461/12526883/7730991c-c127-11e5-9196-98e9ceec758f.png" alt="Deployment list"></p><blockquote><p>注意: 因为他们很少用和需要屏幕，部署密钥默认是不显示的。如果你需要查看它们，只要在deployment ls命令后面加上-k标识即可。</p></blockquote><h4 id="安装指标有如下意义："><a href="#安装指标有如下意义：" class="headerlink" title="安装指标有如下意义："></a>安装指标有如下意义：</h4><ul><li><p>Active（激活） - 成功安装的数量目前运行这个版本。这个数字将会随着用户更新到或离开这个版本分别增加或减少。</p></li><li><p>Total - 该版本更新收到的所有成功安装的总数。这个数字只会随新用户/设备安装它而增加，所以它是<strong>激活</strong>的超集。</p></li><li><p>Pending - 更新被下载了但还没安装的数量。This would only apply to updates that aren’t installed immediately, and helps provide the broader picture of release adoption for apps that rely on app resume and restart to apply an update.</p></li><li><p>Rollbacks - 该版本被自动回滚的次数。理想情况下这个数应该为0，而且在这种情况下这个量是不会显示的。然而，如果你发布了一个包含严重问题(Crash)的更新，CodePush插件将在安装时回滚到上一个版本，同时把问题反馈到服务端。这可以让终端用户依旧能用，不被损坏的版本阻塞住，而且能够在CLI里看到这些，你可以鉴定错误的版本并且能在服务器上做出回滚的响应。</p></li><li><p>Rollout - 显示有资格接收更新的百分比。这个属性只会被显示在那些激活的的首次展示的版本，所以，首次展示百分比是小于100%。此外， 因为一个部署任何时候只能有一个激活的首次展示，这个标签只会被显示在最新的一次部署里。</p></li><li><p>Disabled - 标示是否该版本被标记成失效的，因此用户是否可下载。这个属性只有在版本真实失效时才显示。</p></li></ul><h3 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##操作需要在项目根目录下进行</span></span><br><span class="line">code-push rollback &lt;appName&gt; Production --targetRelease v4(codepush服务部署的版本号)</span><br></pre></td></tr></table></figure><blockquote><p>参考文档 <a href="https://github.com/Microsoft/code-push/blob/master/cli/README-cn.md" target="_blank" rel="noopener">文档1</a> <a href="https://blog.csdn.net/u013718120/article/details/78344866" target="_blank" rel="noopener">文档2</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;用户相关&quot;&gt;&lt;a href=&quot;#用户相关&quot; class=&quot;headerlink&quot; title=&quot;用户相关&quot;&gt;&lt;/a&gt;用户相关&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="code-push常用命令" scheme="https://gofugui.github.io/categories/code-push常用命令/"/>
    
    
    <category term="code-push常用命令" scheme="https://gofugui.github.io/tags/code-push常用命令/"/>
    
  </entry>
  
  <entry>
    <title>高效的js片段</title>
    <link href="https://gofugui.github.io/2018/10/11/JS-Code/"/>
    <id>https://gofugui.github.io/2018/10/11/JS-Code/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2021-03-31T05:57:45.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该项目来自于 Github 用户 Chalarangelo，目前已在 Github 上获得了 5000 多Star，精心收集了多达 48 个有用的 JavaScript 代码片段，该用户的代码可以让程序员在 30 秒甚至更少的时间内理解这些经常用到的基础算法，来看看这些 JavaScript 代码都传达出了什么吧！</p></blockquote><h3 id="1-Anagrams-of-string-带有重复项"><a href="#1-Anagrams-of-string-带有重复项" class="headerlink" title="1.  Anagrams of string(带有重复项)"></a>1.  Anagrams of string(带有重复项)</h3><blockquote><p>使用递归。对于给定字符串中的每个字母，为字母创建字谜。使用map()将字母与每部分字谜组合，然后使用reduce()将所有字谜组合到一个数组中，最基本情况是字符串长度等于2或1。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const anagrams = str =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (str.length &lt;= 2) <span class="built_in">return</span> str.length === 2 ? [str, str[1] + str[0]] : [str];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> str.split(<span class="string">''</span>).reduce((acc, letter, i) =&gt;</span><br><span class="line">  </span><br><span class="line">    acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val =&gt; letter + val)), []);</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># anagrams('abc') -&gt; ['abc','acb','bac','bca','cab','cba']</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-数组平均数"><a href="#2-数组平均数" class="headerlink" title="2.  数组平均数"></a>2.  数组平均数</h3><blockquote><p>使用reduce()将每个值添加到累加器，初始值为0，总和除以数组长度。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const average = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;</span><br><span class="line"></span><br><span class="line"><span class="comment"># average([1,2,3]) -&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="3-大写每个单词的首字母"><a href="#3-大写每个单词的首字母" class="headerlink" title="3.  大写每个单词的首字母"></a>3.  大写每个单词的首字母</h3><blockquote><p>使用replace()匹配每个单词的第一个字符，并使用toUpperCase()来将其大写。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const capitalizeEveryWord = str =&gt; str.replace(/\b[a-z]/g, char =&gt; char.toUpperCase());</span><br><span class="line"></span><br><span class="line"><span class="comment"># capitalizeEveryWord('hello world!') -&gt; 'Hello World!'</span></span><br></pre></td></tr></table></figure><h3 id="4-首字母大写"><a href="#4-首字母大写" class="headerlink" title="4. 首字母大写"></a>4. 首字母大写</h3><blockquote><p>使用slice(0, 1)和toUpperCase()大写第一个字母，slice(1)获取字符串的其余部分。 省略lowerRest参数以保持字符串的其余部分不变，或将其设置为true以转换为小写。(注意：这和上一个示例不是同一件事情)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const capitalize = (str, lowerRest = <span class="literal">false</span>) =&gt;</span><br><span class="line"></span><br><span class="line">str.slice(0, 1).toUpperCase() + (lowerRest ? str.slice(1).toLowerCase() : str.slice(1));</span><br><span class="line"></span><br><span class="line"><span class="comment"># capitalize('myName', true) -&gt; 'Myname'</span></span><br></pre></td></tr></table></figure><h3 id="5-检查回文"><a href="#5-检查回文" class="headerlink" title="5. 检查回文"></a>5. 检查回文</h3><blockquote><p>将字符串转换为toLowerCase()，并使用replace()从中删除非字母的字符。然后，将其转换为tolowerCase()，将(‘’)拆分为单独字符，reverse()，join(‘’)，与原始的非反转字符串进行比较，然后将其转换为tolowerCase()。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const palindrome = str =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const s = str.toLowerCase().replace(/[\W_]/g,<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> s === s.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># palindrome('taco cat') -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="6-计数数组中值的出现次数"><a href="#6-计数数组中值的出现次数" class="headerlink" title="6. 计数数组中值的出现次数"></a>6. 计数数组中值的出现次数</h3><blockquote><p>每次遇到数组中的特定值时，使用reduce()来递增计数器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1 : a + 0, 0);</span><br><span class="line"></span><br><span class="line"><span class="comment"># countOccurrences([1,1,2,1,2,3], 1) -&gt; 3</span></span><br></pre></td></tr></table></figure><h3 id="7-当前URL"><a href="#7-当前URL" class="headerlink" title="7. 当前URL"></a>7. 当前URL</h3><blockquote><p>使用window.location.href来获取当前URL。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const currentUrl = _ =&gt; window.location.href;</span><br><span class="line"></span><br><span class="line"><span class="comment"># currentUrl() -&gt; 'https://google.com'</span></span><br></pre></td></tr></table></figure><h3 id="8-Curry"><a href="#8-Curry" class="headerlink" title="8.  Curry"></a>8.  Curry</h3><blockquote><p>借助bind,参数绑定的特性，如果提供的参数(args)数量足够，则调用传递函数f，否则返回一个curried函数f。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const curry = (fn, arity = fn.length, ...args) =&gt;</span><br><span class="line"></span><br><span class="line">  arity &lt;= args.length</span><br><span class="line"></span><br><span class="line">    ? fn(...args)</span><br><span class="line"></span><br><span class="line">    : curry.bind(null, fn, arity, ...args);</span><br><span class="line"></span><br><span class="line"><span class="comment"># curry(Math.pow)(2)(10) -&gt; 1024</span></span><br><span class="line"><span class="comment"># curry(Math.min, 3)(10)(50)(2) -&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="9-Deep-flatten-array"><a href="#9-Deep-flatten-array" class="headerlink" title="9.  Deep flatten array"></a>9.  Deep flatten array</h3><blockquote><p>使用递归，使用reduce()来获取所有不是数组的元素，flatten每个元素都是数组。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const deepFlatten = arr =&gt;</span><br><span class="line"></span><br><span class="line">  arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? deepFlatten(v) : v), []);</span><br><span class="line"></span><br><span class="line"><span class="comment"># deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h3 id="10-数组之间的区别"><a href="#10-数组之间的区别" class="headerlink" title="10.  数组之间的区别"></a>10.  数组之间的区别</h3><blockquote><p>从b创建一个Set，然后在a上使用Array.filter()，只保留b中不包含的值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const difference = (a, b) =&gt; &#123; const s = new Set(b); <span class="built_in">return</span> a.filter(x =&gt; !s.has(x)); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># difference([1,2,3], [1,2]) -&gt; [3]</span></span><br></pre></td></tr></table></figure><h3 id="11-两点之间的距离"><a href="#11-两点之间的距离" class="headerlink" title="11.  两点之间的距离"></a>11.  两点之间的距离</h3><blockquote><p>使用Math.hypot()计算两点之间的欧几里德距离。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const distance = (x0, y0, x1, y1) =&gt; Math.hypot(x1 - x0, y1 - y0);</span><br><span class="line"></span><br><span class="line"><span class="comment"># distance(1,1, 2,3) -&gt; 2.23606797749979</span></span><br></pre></td></tr></table></figure><h3 id="12-可以按数字整除"><a href="#12-可以按数字整除" class="headerlink" title="12.  可以按数字整除"></a>12.  可以按数字整除</h3><blockquote><p>使用模运算符(％)来检查余数是否等于0。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;</span><br><span class="line"></span><br><span class="line"><span class="comment"># isDivisible(6,3) -&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="13-转义正则表达式"><a href="#13-转义正则表达式" class="headerlink" title="13.  转义正则表达式"></a>13.  转义正则表达式</h3><blockquote><p>使用replace()来转义特殊字符。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const escapeRegExp = str =&gt; str.replace(/[.*+?^<span class="variable">$&#123;&#125;</span>()|[\]\\]/g, <span class="string">'\\&gt;&lt;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># escapeRegExp('(test)') -&gt; \\(test\\)</span></span><br></pre></td></tr></table></figure><h3 id="14-偶数或奇数"><a href="#14-偶数或奇数" class="headerlink" title="14.  偶数或奇数"></a>14.  偶数或奇数</h3><blockquote><p>使用Math.abs()将逻辑扩展为负数，使用模(％)运算符进行检查。 如果数字是偶数，则返回true；如果数字是奇数，则返回false。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const isEven = num =&gt; num % 2 === 0;</span><br><span class="line"></span><br><span class="line"><span class="comment"># isEven(3) -&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="15-阶乘"><a href="#15-阶乘" class="headerlink" title="15.  阶乘"></a>15.  阶乘</h3><blockquote><p>使用递归。如果n小于或等于1，则返回1。否则返回n和n – 1的阶乘的乘积。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const factorial = n =&gt; n &lt;= 1 ? 1 : n * factorial(n - 1);</span><br><span class="line"></span><br><span class="line"><span class="comment"># factorial(6) -&gt; 720</span></span><br></pre></td></tr></table></figure><h3 id="16-斐波那契数组生成器"><a href="#16-斐波那契数组生成器" class="headerlink" title="16.  斐波那契数组生成器"></a>16.  斐波那契数组生成器</h3><blockquote><p>创建一个特定长度的空数组，初始化前两个值(0和1)。使用Array.reduce()向数组中添加值，后面的一个数等于前面两个数相加之和(前两个除外)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fibonacci = n =&gt;</span><br><span class="line"></span><br><span class="line">  Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);</span><br><span class="line"></span><br><span class="line"><span class="comment"># fibonacci(5) -&gt; [0,1,1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="17-过滤数组中的非唯一值"><a href="#17-过滤数组中的非唯一值" class="headerlink" title="17.  过滤数组中的非唯一值"></a>17.  过滤数组中的非唯一值</h3><blockquote><p>将Array.filter()用于仅包含唯一值的数组。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));</span><br><span class="line"></span><br><span class="line"><span class="comment"># filterNonUnique([1,2,2,3,4,4,5]) -&gt; [1,3,5]</span></span><br></pre></td></tr></table></figure><h3 id="18-Flatten数组"><a href="#18-Flatten数组" class="headerlink" title="18. Flatten数组"></a>18. Flatten数组</h3><blockquote><p>使用reduce()来获取数组中的所有元素，并使用concat()来使它们flatten。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const flatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(v), []);</span><br><span class="line"></span><br><span class="line"><span class="comment"># flatten([1,[2],3,4]) -&gt; [1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="19-从数组中获取最大值"><a href="#19-从数组中获取最大值" class="headerlink" title="19. 从数组中获取最大值"></a>19. 从数组中获取最大值</h3><blockquote><p>使用Math.max()与spread运算符(…)结合得到数组中的最大值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arrayMax = arr =&gt; Math.max(...arr);</span><br><span class="line"></span><br><span class="line"><span class="comment"># arrayMax([10, 1, 5]) -&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="20-从数组中获取最小值"><a href="#20-从数组中获取最小值" class="headerlink" title="20. 从数组中获取最小值"></a>20. 从数组中获取最小值</h3><blockquote><p>使用Math.min()与spread运算符(…)结合得到数组中的最小值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arrayMin = arr =&gt; Math.min(...arr);</span><br><span class="line"></span><br><span class="line"><span class="comment"># arrayMin([10, 1, 5]) -&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="21-获取滚动位置"><a href="#21-获取滚动位置" class="headerlink" title="21. 获取滚动位置"></a>21. 获取滚动位置</h3><blockquote><p>如果已定义，请使用pageXOffset和pageYOffset，否则使用scrollLeft和scrollTop，可以省略el来使用window的默认值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const getScrollPos = (el = window) =&gt;</span><br><span class="line"></span><br><span class="line">  (&#123;x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,</span><br><span class="line"></span><br><span class="line">    y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># getScrollPos() -&gt; &#123;x: 0, y: 200&#125;</span></span><br></pre></td></tr></table></figure><h3 id="22-最大公约数-GCD"><a href="#22-最大公约数-GCD" class="headerlink" title="22. 最大公约数(GCD)"></a>22. 最大公约数(GCD)</h3><blockquote><p>使用递归。基本情况是当y等于0时。在这种情况下，返回x。否则，返回y的GCD和x / y的其余部分。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);</span><br><span class="line"><span class="comment"># gcd (8, 36) -&gt; 4</span></span><br></pre></td></tr></table></figure><h3 id="23-Head-of-list"><a href="#23-Head-of-list" class="headerlink" title="23. Head of list"></a>23. Head of list</h3><blockquote><p>返回ARR[0]</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const head = arr =&gt; arr[0];</span><br><span class="line"></span><br><span class="line"><span class="comment"># head([1,2,3]) -&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="24-list初始化"><a href="#24-list初始化" class="headerlink" title="24. list初始化"></a>24. list初始化</h3><blockquote><p>返回arr.slice(0，-1)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const initial = arr =&gt; arr.slice(0, -1);</span><br><span class="line"></span><br><span class="line"><span class="comment"># initial([1,2,3]) -&gt; [1,2]</span></span><br></pre></td></tr></table></figure><h3 id="25-用range初始化数组"><a href="#25-用range初始化数组" class="headerlink" title="25. 用range初始化数组"></a>25. 用range初始化数组</h3><blockquote><p>使用Array(end-start)创建所需长度的数组，使用map()来填充范围中的所需值，可以省略start使用默认值0。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const initializeArrayRange = (end, start = 0) =&gt;</span><br><span class="line"></span><br><span class="line">  Array.apply(null, Array(end - start)).map((v, i) =&gt; i + start);</span><br><span class="line"></span><br><span class="line"><span class="comment"># initializeArrayRange(5) -&gt; [0,1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="26-用值初始化数组"><a href="#26-用值初始化数组" class="headerlink" title="26. 用值初始化数组"></a>26. 用值初始化数组</h3><blockquote><p>使用Array(n)创建所需长度的数组，fill(v)以填充所需的值，可以忽略value使用默认值0。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const initializeArray = (n, value = 0) =&gt; Array(n).fill(value);</span><br><span class="line"></span><br><span class="line"><span class="comment"># initializeArray(5, 2) -&gt; [2,2,2,2,2]</span></span><br></pre></td></tr></table></figure><h3 id="27-列表的最后"><a href="#27-列表的最后" class="headerlink" title="27. 列表的最后"></a>27. 列表的最后</h3><blockquote><p>返回arr.slice(-1)[0]</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const last = arr =&gt; arr.slice(-1)[0];</span><br><span class="line"></span><br><span class="line"><span class="comment"># last([1,2,3]) -&gt; 3</span></span><br></pre></td></tr></table></figure><h3 id="28-测试功能所花费的时间"><a href="#28-测试功能所花费的时间" class="headerlink" title="28. 测试功能所花费的时间"></a>28. 测试功能所花费的时间</h3><blockquote><p>使用performance.now()获取函数的开始和结束时间，console.log()所花费的时间。第一个参数是函数名，随后的参数传递给函数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const timeTaken = callback =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  console.time(<span class="string">'timeTaken'</span>);</span><br><span class="line"></span><br><span class="line">  const r = callback();</span><br><span class="line"></span><br><span class="line">  console.timeEnd(<span class="string">'timeTaken'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> r;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (logged): timeTaken: 0.02099609375ms</span></span><br></pre></td></tr></table></figure><h3 id="29-来自键值对的对象"><a href="#29-来自键值对的对象" class="headerlink" title="29. 来自键值对的对象"></a>29. 来自键值对的对象</h3><blockquote><p>使用Array.reduce()来创建和组合键值对。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const objectFromPairs = arr =&gt; arr.reduce((a, v) =&gt; (a[v[0]] = v[1], a), &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment"># objectFromPairs([['a',1],['b',2]]) -&gt; &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="30-管道"><a href="#30-管道" class="headerlink" title="30. 管道"></a>30. 管道</h3><blockquote><p>使用Array.reduce()通过函数传递值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const pipe = (...funcs) =&gt; arg =&gt; funcs.reduce((acc, func) =&gt; func(acc), arg);</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipe(btoa, x =&gt; x.toUpperCase())("Test") -&gt; "VGVZDA=="</span></span><br></pre></td></tr></table></figure><h3 id="31-Powerset"><a href="#31-Powerset" class="headerlink" title="31. Powerset"></a>31. Powerset</h3><blockquote><p>使用reduce()与map()结合来遍历元素，并将其组合成包含所有组合的数组。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const powerset = arr =&gt;</span><br><span class="line"></span><br><span class="line">  arr.reduce((a, v) =&gt; a.concat(a.map(r =&gt; [v].concat(r))), [[]]);</span><br><span class="line"></span><br><span class="line"><span class="comment"># powerset([1,2]) -&gt; [[], [1], [2], [2,1]]</span></span><br></pre></td></tr></table></figure><h3 id="32-范围内的随机整数"><a href="#32-范围内的随机整数" class="headerlink" title="32. 范围内的随机整数"></a>32. 范围内的随机整数</h3><blockquote><p>使用Math.random()生成一个随机数并将其映射到所需的范围，使用Math.floor()使其成为一个整数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const randomIntegerInRange = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line"></span><br><span class="line"><span class="comment"># randomIntegerInRange(0, 5) -&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="33-范围内的随机数"><a href="#33-范围内的随机数" class="headerlink" title="33. 范围内的随机数"></a>33. 范围内的随机数</h3><blockquote><p>使用Math.random()生成一个随机值，使用乘法将其映射到所需的范围。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const randomInRange = (min, max) =&gt; Math.random() * (max - min) + min;</span><br><span class="line"></span><br><span class="line"><span class="comment"># randomInRange(2,10) -&gt; 6.0211363285087005</span></span><br></pre></td></tr></table></figure><h3 id="34-随机化数组的顺序"><a href="#34-随机化数组的顺序" class="headerlink" title="34. 随机化数组的顺序"></a>34. 随机化数组的顺序</h3><blockquote><p>使用sort()重新排序元素，利用Math.random()来随机排序。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const shuffle = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);</span><br><span class="line"></span><br><span class="line"><span class="comment"># shuffle([1,2,3]) -&gt; [2,3,1]</span></span><br></pre></td></tr></table></figure><h3 id="35-重定向到URL"><a href="#35-重定向到URL" class="headerlink" title="35. 重定向到URL"></a>35. 重定向到URL</h3><blockquote><p>使用window.location.href或window.location.replace()重定向到url。 传递第二个参数来模拟链接点击(true – default)或HTTP重定向(false)。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const redirect = (url, asLink = <span class="literal">true</span>) =&gt;</span><br><span class="line"></span><br><span class="line">  asLink ? window.location.href = url : window.location.replace(url);</span><br><span class="line"></span><br><span class="line"><span class="comment"># redirect('https://google.com')</span></span><br></pre></td></tr></table></figure><h3 id="36-反转一个字符串"><a href="#36-反转一个字符串" class="headerlink" title="36.  反转一个字符串"></a>36.  反转一个字符串</h3><blockquote><p>使用数组解构和Array.reverse()来颠倒字符串中的字符顺序。合并字符以使用join(‘’)获取字符串。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const reverseString = str =&gt; [...str].reverse().join(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverseString('foobar') -&gt; 'raboof'</span></span><br></pre></td></tr></table></figure><h3 id="37-RGB到十六进制"><a href="#37-RGB到十六进制" class="headerlink" title="37.  RGB到十六进制"></a>37.  RGB到十六进制</h3><blockquote><p>使用按位左移运算符(&lt;&lt;)和toString(16)，然后padStart(6，“0”)将给定的RGB参数转换为十六进制字符串以获得6位十六进制值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const rgbToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># rgbToHex(255, 165, 1) -&gt; 'ffa501'</span></span><br></pre></td></tr></table></figure><h3 id="38-滚动到顶部"><a href="#38-滚动到顶部" class="headerlink" title="38.  滚动到顶部"></a>38.  滚动到顶部</h3><blockquote><p>使用document.documentElement.scrollTop或document.body.scrollTop获取到顶部的距离。从顶部滚动一小部分距离。使用window.requestAnimationFrame()来滚动。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const scrollToTop = _ =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const c = document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (c &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">    window.requestAnimationFrame(scrollToTop);</span><br><span class="line"></span><br><span class="line">    window.scrollTo(0, c - c / 8);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># scrollToTop()</span></span><br></pre></td></tr></table></figure><h3 id="39-随机数组值"><a href="#39-随机数组值" class="headerlink" title="39.  随机数组值"></a>39.  随机数组值</h3><blockquote><p>使用Array.map()和Math.random()创建一个随机值的数组。使用Array.sort()根据随机值对原始数组的元素进行排序。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const shuffle = arr =&gt; &#123;</span><br><span class="line">  <span class="built_in">let</span> r = arr.map(Math.random);</span><br><span class="line">  <span class="built_in">return</span> arr.sort((a, b) =&gt; r[a] - r[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># shuffle([1, 2, 3] -&gt; [2, 1, 3])</span></span><br></pre></td></tr></table></figure><h3 id="40-数组之间的相似性"><a href="#40-数组之间的相似性" class="headerlink" title="40.  数组之间的相似性"></a>40.  数组之间的相似性</h3><blockquote><p>使用filter()移除不是values的一部分值，使用includes()确定。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));</span><br><span class="line"></span><br><span class="line"><span class="comment"># similarity([1,2,3], [1,2,4]) -&gt; [1,2]</span></span><br></pre></td></tr></table></figure><h3 id="41-按字符串排序-按字母顺序排列"><a href="#41-按字符串排序-按字母顺序排列" class="headerlink" title="41.  按字符串排序(按字母顺序排列)"></a>41.  按字符串排序(按字母顺序排列)</h3><blockquote><p>使用split(‘’)分割字符串，sort()使用localeCompare()，使用join(‘’)重新组合。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sortCharactersInString = str =&gt;</span><br><span class="line"></span><br><span class="line">  str.split(<span class="string">''</span>).sort((a, b) =&gt; a.localeCompare(b)).join(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># sortCharactersInString('cabbage') -&gt; 'aabbceg'</span></span><br></pre></td></tr></table></figure><h3 id="42-数组总和"><a href="#42-数组总和" class="headerlink" title="42. 数组总和"></a>42. 数组总和</h3><blockquote><p>使用reduce()将每个值添加到累加器，初始化值为0。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sum = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0);</span><br><span class="line"></span><br><span class="line"><span class="comment"># sum([1,2,3,4]) -&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="43-交换两个变量的值"><a href="#43-交换两个变量的值" class="headerlink" title="43. 交换两个变量的值"></a>43. 交换两个变量的值</h3><blockquote><p>使用数组解构来交换两个变量之间的值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[varA, varB] = [varB, varA];</span><br><span class="line"></span><br><span class="line"><span class="comment"># [x, y] = [y, x]</span></span><br></pre></td></tr></table></figure><h3 id="44-列表的tail"><a href="#44-列表的tail" class="headerlink" title="44. 列表的tail"></a>44. 列表的tail</h3><blockquote><p>返回arr.slice(1)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const tail = arr =&gt; arr.length &gt; 1 ? arr.slice(1) : arr;</span><br><span class="line"></span><br><span class="line"><span class="comment"># tail([1,2,3]) -&gt; [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tail([1]) -&gt; [1]</span></span><br></pre></td></tr></table></figure><h3 id="45-数组唯一值"><a href="#45-数组唯一值" class="headerlink" title="45. 数组唯一值"></a>45. 数组唯一值</h3><blockquote><p>使用ES6 Set和… rest操作符去掉所有重复值。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const unique = arr =&gt; [...new Set(arr)];</span><br><span class="line"></span><br><span class="line"><span class="comment"># unique([1,2,2,3,4,4,5]) -&gt; [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h3 id="46-URL参数"><a href="#46-URL参数" class="headerlink" title="46. URL参数"></a>46. URL参数</h3><blockquote><p>使用match() 与适当的正则表达式来获得所有键值对，适当的map() 。使用Object.assign()和spread运算符(…)将所有键值对组合到一个对象中，将location.search作为参数传递给当前url。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const getUrlParameters = url =&gt;</span><br><span class="line"></span><br><span class="line">  url.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce(</span><br><span class="line"></span><br><span class="line">    (a, v) =&gt; (a[v.slice(0, v.indexOf(<span class="string">'='</span>))] = v.slice(v.indexOf(<span class="string">'='</span>) + 1), a), &#123;&#125;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment"># getUrlParameters('http://url.com/page?name=Adam&amp;surname=Smith') -&gt; &#123;name: 'Adam', surname: 'Smith'&#125;</span></span><br></pre></td></tr></table></figure><h3 id="47-UUID生成器"><a href="#47-UUID生成器" class="headerlink" title="47. UUID生成器"></a>47. UUID生成器</h3><blockquote><p>使用crypto API生成符合RFC4122版本4的UUID。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const uuid = _ =&gt;</span><br><span class="line"></span><br><span class="line">  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt;</span><br><span class="line"></span><br><span class="line">    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"># uuid() -&gt; &apos;7982fcfe-5721-4632-bede-6000885be57d&apos;</span><br></pre></td></tr></table></figure><h3 id="48-验证数字"><a href="#48-验证数字" class="headerlink" title="48.  验证数字"></a>48.  验证数字</h3><blockquote><p>使用！isNaN和parseFloat()来检查参数是否是一个数字，使用isFinite()来检查数字是否是有限的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;</span><br><span class="line"></span><br><span class="line"># validateNumber(&apos;10&apos;) -&gt; true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;该项目来自于 Github 用户 Chalarangelo，目前已在 Github 上获得了 5000 多Star，精心收集了多达 48 个有用的 JavaScript 代码片段，该用户的代码可以让程序员在 30 秒甚至更少的时间内理解这些经常用到</summary>
      
    
    
    
    <category term="前端" scheme="https://gofugui.github.io/categories/前端/"/>
    
    
    <category term="JavaScript" scheme="https://gofugui.github.io/tags/JavaScript/"/>
    
    <category term="Web" scheme="https://gofugui.github.io/tags/Web/"/>
    
    <category term="ES6" scheme="https://gofugui.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
