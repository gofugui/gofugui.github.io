<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="前端基础概念"><meta name="keywords" content="JavaScript,Web,ES6,html"><meta name="author" content="Sir_Liu"><meta name="copyright" content="Sir_Liu"><title>前端基础概念 | Coding Your Life</title><link rel="shortcut icon" href="/vite.svg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4583227810964573" crossorigin="anonymous"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '3.9.0'
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用堆栈"><span class="toc-number">1.</span> <span class="toc-text">调用堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原始类型"><span class="toc-number">2.</span> <span class="toc-text">原始类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#值类型和引用类型"><span class="toc-number">3.</span> <span class="toc-text">值类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式-显式-名义和鸭子类型"><span class="toc-number">4.</span> <span class="toc-text">隐式, 显式, 名义和鸭子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与-typeof-与-instanceof"><span class="toc-number">5.</span> <span class="toc-text">== 与 ===, typeof 与 instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-call-apply-和-bind"><span class="toc-number">6.</span> <span class="toc-text">this, call, apply 和 bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数作用域-块级作用域和词法作用域"><span class="toc-number">7.</span> <span class="toc-text">函数作用域, 块级作用域和词法作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">8.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-reduce-filter-等高阶函数"><span class="toc-number">9.</span> <span class="toc-text">map, reduce, filter 等高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量提升"><span class="toc-number">10.</span> <span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">11.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#立即执行函数-模块化-命名空间"><span class="toc-number">12.</span> <span class="toc-text">立即执行函数, 模块化, 命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归"><span class="toc-number">13.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">14.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">15.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息队列和事件循环"><span class="toc-number">16.</span> <span class="toc-text">消息队列和事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-setInterval-和requestAnimationFrame"><span class="toc-number">17.</span> <span class="toc-text">setTimeout, setInterval 和requestAnimationFrame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态和代码复用"><span class="toc-number">18.</span> <span class="toc-text">多态和代码复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按位操作符-类数组对象和类型化数组"><span class="toc-number">19.</span> <span class="toc-text">按位操作符, 类数组对象和类型化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-树和渲染过程"><span class="toc-number">20.</span> <span class="toc-text">DOM 树和渲染过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-与构造函数-instanceof-与实例"><span class="toc-number">21.</span> <span class="toc-text">new 与构造函数, instanceof 与实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型继承与原型链"><span class="toc-number">22.</span> <span class="toc-text">原型继承与原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-create-和-Object-assign"><span class="toc-number">23.</span> <span class="toc-text">Object.create 和 Object.assign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂函数和类"><span class="toc-number">24.</span> <span class="toc-text">工厂函数和类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-number">25.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memoization"><span class="toc-number">26.</span> <span class="toc-text">Memoization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纯函数-函数副作用和状态变化"><span class="toc-number">27.</span> <span class="toc-text">纯函数, 函数副作用和状态变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#耗性能操作和时间复杂度"><span class="toc-number">28.</span> <span class="toc-text">耗性能操作和时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-引擎"><span class="toc-number">29.</span> <span class="toc-text">JavaScript 引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制-十进制-十六进制-科学记数法"><span class="toc-number">30.</span> <span class="toc-text">二进制, 十进制, 十六进制, 科学记数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏函数-柯里化-Compose-和-Pipe"><span class="toc-number">31.</span> <span class="toc-text">偏函数, 柯里化, Compose 和 Pipe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码整洁之道"><span class="toc-number">32.</span> <span class="toc-text">代码整洁之道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise执行顺序"><span class="toc-number">33.</span> <span class="toc-text">promise执行顺序</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/mirror-assets/16d2a30b4d8e2a895e6~tplv-t2oaga2asx-jj-mark:72:72:0:0:q75.avis"></div><div class="author-info__name text-center">Sir_Liu</div><div class="author-info__description text-center">无论从事什么行业，只要做好两件事就够了，一个是你的专业、一个是你的人品，专业决定了你的存在，人品决定了你的人脉，剩下的就是坚持，用善良專業和真诚赢取更多的信任。（No matter what industry you are in, it is enough to do two things well, one is your profession and the other is your character. Your profession determines your existence, and your character determines your network. The rest is persistence, and you should win more trust with kindness, professionalism and sincerity.）</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(chrome-extension://pkfjcehoipcdbiilobhcblbkmelocaka/start/skin/images/bg-51.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coding Your Life</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">前端基础概念</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 15 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。</span><br><span class="line"></span><br><span class="line">每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。</span><br><span class="line">正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。</span><br><span class="line">当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。</span><br><span class="line">当分配的调用栈空间被占满时，会引发“堆栈溢出”错误。</span><br></pre></td></tr></table></figure>
<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最新的 ECMAScript 标准定义了 9 种数据类型:</span></span><br><span class="line"><span class="comment"># 6 种原始类型，使用 typeof 运算符检查:</span></span><br><span class="line"></span><br><span class="line">undefined: typeof =&gt; <span class="string">'undefined'</span></span><br><span class="line">Boolean: typeof =&gt; <span class="string">'boolean'</span></span><br><span class="line">Number: typeof =&gt; <span class="string">'number'</span></span><br><span class="line">String: typeof =&gt; <span class="string">'string'</span></span><br><span class="line">BigInt: typeof =&gt; <span class="string">'bigint'</span></span><br><span class="line">Symbol: typeof =&gt; <span class="string">'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象和函数类型</span></span><br><span class="line">null: typeof =&gt; <span class="string">'object'</span></span><br><span class="line">Object: typeof =&gt; <span class="string">'object'</span></span><br><span class="line">Function: typeof =&gt; <span class="string">'function'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 内建对象 typeof =&gt; 'function'</span></span><br><span class="line">Date</span><br><span class="line">Array </span><br><span class="line">Map</span><br><span class="line">Set</span><br><span class="line">WeakMap</span><br><span class="line">WeakSet</span><br><span class="line">Regxp</span><br></pre></td></tr></table></figure>
<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值类型：</span></span><br><span class="line">string, number, boolean, undefined, bigint, symbol 和 null</span><br><span class="line"><span class="comment"># 引用类型：</span></span><br><span class="line">Object, Array, Function,...</span><br></pre></td></tr></table></figure>
<h3 id="隐式-显式-名义和鸭子类型"><a href="#隐式-显式-名义和鸭子类型" class="headerlink" title="隐式, 显式, 名义和鸭子类型"></a>隐式, 显式, 名义和鸭子类型</h3><p><strong>JavaScript 是一种<code>弱类型</code>或者说<code>动态</code>语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = 42;   <span class="comment"># foo is a Number now</span></span><br><span class="line">foo = <span class="string">"bar"</span>;    <span class="comment"># foo is a String now</span></span><br><span class="line">foo = <span class="literal">true</span>;     <span class="comment"># foo is a Boolean now</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐式转换为布尔：“truthy”和“falsy”。当 JavaScript 需要一个布尔值时（例如：if 语句），任何值都可以被使用。 最终这些值将被转换为 true 或 false。</span></span><br><span class="line"><span class="string">''</span>, +0, -0, NaN, null, undefined, 0, 转换为boolean类型的时候都是<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="与-typeof-与-instanceof"><a href="#与-typeof-与-instanceof" class="headerlink" title="== 与 ===, typeof 与 instanceof"></a>== 与 ===, typeof 与 instanceof</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># == 会进行隐式转换</span></span><br><span class="line">    1.如果比较的两者中有布尔值(Boolean)，会把 Boolean 先转换为对应的 Number，即 0 和 1，然后进行比较。</span><br><span class="line">    2.如果比较的双方中有一方为 Number，一方为 String时，会把 String 通过 Number() 方法转换为数字，然后进行比较。</span><br><span class="line">    3.如果比较的双方中有一方为 Boolean，一方为 String时，会将双方转换为数字，然后再进行比较。</span><br><span class="line">    4.如果比较的双方中有一方为 Number，一方为Object时，则会调用 valueOf 方法将Object转换为数字，然后进行比较。 </span><br><span class="line"><span class="comment"># === 不会进行转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># typeof 返回数据类型的 类型标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># instanceof 运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上</span></span><br></pre></td></tr></table></figure>
<h3 id="this-call-apply-和-bind"><a href="#this-call-apply-和-bind" class="headerlink" title="this, call, apply 和 bind"></a>this, call, apply 和 bind</h3><p><strong>与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别。</strong><br><strong>在绝大多数情况下，函数的调用方式决定了this的值  <code>（运行时绑定）</code>，所以this的值在每次函数调用的时候都可能不同。es5 中引入了bind来设置this的值。</strong><br><strong>需要指出的是在es2015中引入的箭头函数中，不提供自身的this绑定，其this值保持为闭合词法的上下文值</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># call ,apply</span></span><br><span class="line">二者作用类似，都是指定具体this和参数调用函数，区别是call调用时参数以列表的形式传递，而apply则是以数组的形式传递参数</span><br></pre></td></tr></table></figure></p>
<h3 id="函数作用域-块级作用域和词法作用域"><a href="#函数作用域-块级作用域和词法作用域" class="headerlink" title="函数作用域, 块级作用域和词法作用域"></a>函数作用域, 块级作用域和词法作用域</h3><p>作用域：当前执行的上下文。值和表达式在其中“可见“或者可以被访问到的上下文，js作用域以链的形式存在。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js代码执行时，首先回创建一个全局的执行上下文</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数作用域</span></span><br><span class="line">通常情况下，在函数内部定义的变量不能在函数之外的任何地方访问，同时内部函数包含外部函数作用域。</span><br><span class="line"><span class="comment"># 块级作用域</span></span><br><span class="line">在js中函数块是🈯️被&#123;&#125;包裹住的相关联的状态集合，例如一个<span class="keyword">for</span>循环体，一个条件<span class="keyword">if</span>判断都可以纳入一个块级作用域范围</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>你可以在函数的内部再定义一个函数，嵌套函数对其容器函数是私有的，他自身也形成了一个闭包，当闭包内包含外部作用域的参数和变量时，会保存其值，当一个闭包中进行变量查找时，更近的作用域有更高的优先权，这就形成了作用域链</strong></p>
<h3 id="map-reduce-filter-等高阶函数"><a href="#map-reduce-filter-等高阶函数" class="headerlink" title="map, reduce, filter 等高阶函数"></a>map, reduce, filter 等高阶函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># map</span></span><br><span class="line">map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</span><br><span class="line"><span class="comment"># reduce </span></span><br><span class="line">reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</span><br><span class="line"><span class="comment"># filter</span></span><br><span class="line">filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</span><br></pre></td></tr></table></figure>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><strong>其实质是变量的声明提升</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(b)  <span class="comment"># undefined</span></span><br><span class="line">var b;          <span class="comment"># 声明提升</span></span><br><span class="line"></span><br><span class="line">console.log(c)  <span class="comment"># VM315:1 Uncaught ReferenceError: c is not defined</span></span><br><span class="line"><span class="built_in">let</span> c;          <span class="comment"># let 和 const 声明的无法提升变量声明</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><strong>Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个 Promise 必然处于以下几种状态之一：</span><br><span class="line"><span class="comment"># 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。</span></span><br><span class="line"><span class="comment"># 已兑现（fulfilled）: 意味着操作成功完成。</span></span><br><span class="line"><span class="comment"># 已拒绝（rejected）: 意味着操作失败。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="立即执行函数-模块化-命名空间"><a href="#立即执行函数-模块化-命名空间" class="headerlink" title="立即执行函数, 模块化, 命名空间"></a>立即执行函数, 模块化, 命名空间</h3><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="headerlink" title="消息队列和事件循环"></a>消息队列和事件循环</h3><p><strong>JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其它语言中的模型截然不同，比如 C 和 Java。</strong></p>
<p>一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。</p>
<p>在 事件循环 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p>
<p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 之所以称之为 事件循环，是因为它经常按照类似如下的方式来被实现：</span></span><br><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。</p>
<h3 id="setTimeout-setInterval-和requestAnimationFrame"><a href="#setTimeout-setInterval-和requestAnimationFrame" class="headerlink" title="setTimeout, setInterval 和requestAnimationFrame"></a>setTimeout, setInterval 和requestAnimationFrame</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setTimeout</span></span><br><span class="line">由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。</span><br><span class="line">定时器</span><br><span class="line">需要做this绑定，或者使用函数包裹，箭头函数解决</span><br><span class="line"><span class="comment"># requestAnimationFrame</span></span><br><span class="line">window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</span><br></pre></td></tr></table></figure>
<h3 id="多态和代码复用"><a href="#多态和代码复用" class="headerlink" title="多态和代码复用"></a>多态和代码复用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多态</span></span><br></pre></td></tr></table></figure>
<h3 id="按位操作符-类数组对象和类型化数组"><a href="#按位操作符-类数组对象和类型化数组" class="headerlink" title="按位操作符, 类数组对象和类型化数组"></a>按位操作符, 类数组对象和类型化数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按位与</span></span><br><span class="line">两个操作数都为1时，则在该位返回1</span><br><span class="line"><span class="comment"># 按位或</span></span><br><span class="line">两个操作数对应位只要有一个为1，则在该位返回1</span><br><span class="line"><span class="comment"># 按位异或</span></span><br><span class="line">两个操作数的对应位只有一个为1，则在该位返回1</span><br><span class="line"><span class="comment"># 按位取反</span></span><br><span class="line">遇0则返回1，反之亦然</span><br><span class="line"><span class="comment"># 应用</span></span><br><span class="line">1、通过位运算符取整</span><br><span class="line">3.14|0 ; // 3</span><br></pre></td></tr></table></figure>
<h3 id="DOM-树和渲染过程"><a href="#DOM-树和渲染过程" class="headerlink" title="DOM 树和渲染过程"></a>DOM 树和渲染过程</h3><p>DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分</p>
<p>等待资源加载时间和大部分情况下的浏览器单线程执行是影响Web性能的两大主要原因。</p>
<p>通过了解浏览器单线程的本质与最小化主线程的责任可以优化Web性能，来确保渲染的流畅和交互响应的及时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DNS查找</span></span><br><span class="line">对于一个web页面来说导航的第一步是要去寻找页面资源的位置。如果导航到https://example.com, HTML页面 被定为到IP地址为 93.184.216.34 的服务器。如果以前没有访问过这个网站，就需要进行DNS查找。</span><br><span class="line"><span class="comment"># TCP握手</span></span><br><span class="line">TCP的”三次握手“技术经常被称为”SYN-SYN-ACK“—更确切的说是 SYN, SYN-ACK, ACK—因为通过TCP首先发送了三个消息进行协商，开始一个TCP会话在两台电脑之间。 是的，这意味着每台服务器之间还要来回发送三条消息，而请求尚未发出。</span><br><span class="line"><span class="comment"># TLS协商</span></span><br><span class="line">为了在HTTPS上建立安全连接，另一种握手是必须的。更确切的说是TLS协商 ，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。</span><br><span class="line"><span class="comment"># 响应</span></span><br><span class="line">一旦我们建立了到web服务器的连接，浏览器就代表用户发送一个初始的HTTP GET请求，对于网站来说，这个请求通常是一个HTML文件。 一旦服务器收到请求，它将使用相关的响应头和HTML的内容进行回复。</span><br><span class="line"><span class="comment"># tcp慢开始/14kb规则</span></span><br><span class="line">第一个响应包是14kb大小。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。</span><br><span class="line"><span class="comment"># 拥塞控制</span></span><br><span class="line">当服务器用TCP包来发送数据时，客户端通过返回确认帧来确认传输。由于硬件和网络条件，连接的容量是有限的。 如果服务器太快地发送太多的包，它们可能会被丢弃。意味着，将不会有确认帧的返回。服务器把它们当做确认帧丢失。拥塞控制算法使用这个发送包和确认帧流来确定发送速率。</span><br><span class="line"><span class="comment"># 解析</span></span><br><span class="line">一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。</span><br><span class="line">“推测性解析”，“解析”是浏览器将通过网络接收的数据转换为DOM和CSSOM的步骤，通过渲染器把DOM和CSSOM在屏幕上绘制成页面。</span><br><span class="line">即使请求页面的HTML大于初始的14KB数据包，浏览器也将开始解析并尝试根据其拥有的数据进行渲染。这就是为什么在前14Kb中包含浏览器开始渲染页面所需的所有内容，或者至少包含页面模板（第一次渲染所需的CSS和HTML）对于web性能优化来说是重要的。但是在渲染到屏幕上面之前，HTML、CSS、JavaScript必须被解析完成。</span><br><span class="line"><span class="comment"># 构建DOM树</span></span><br><span class="line">第一步是处理HTML标记并构造DOM树。HTML解析涉及到 tokenization 和树的构造。HTML标记包括开始和结束标记，以及属性名和值。 如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建文档树。</span><br><span class="line">当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个CSS文件时，解析也可以继续进行，但是对于&lt;script&gt;标签（特别是没有 async 或者 defer 属性）会阻塞渲染并停止HTML的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。</span><br><span class="line"><span class="comment"># 预加载扫描器</span></span><br><span class="line"><span class="comment"># 构建cssom树</span></span><br><span class="line">DOM和CSSOM是两棵树. 它们是独立的数据结构。浏览器将CSS规则转换为可以理解和使用的样式映射。浏览器遍历CSS中的每个规则集，根据CSS选择器创建具有父、子和兄弟关系的节点树。</span><br><span class="line"><span class="comment"># javascript编译</span></span><br><span class="line">当CSS被解析并创建CSSOM时，其他资源，包括JavaScript文件正在下载（多亏了preload scanner）。JavaScript被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用”Abstract Syntax Tree“并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的JavaScript编译。</span><br><span class="line"><span class="comment"># 渲染</span></span><br><span class="line">渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。</span><br><span class="line">在解析步骤中创建的CSSOM树和DOM树组合成一个Render树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。</span><br><span class="line"></span><br><span class="line">知识点：</span><br><span class="line">Layout</span><br><span class="line">a、回流</span><br><span class="line">回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。</span><br><span class="line">b、重绘</span><br></pre></td></tr></table></figure>
<h3 id="new-与构造函数-instanceof-与实例"><a href="#new-与构造函数-instanceof-与实例" class="headerlink" title="new 与构造函数, instanceof 与实例"></a>new 与构造函数, instanceof 与实例</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  new 关键字会进行如下的操作：</span></span><br><span class="line"></span><br><span class="line">1、创建一个空的简单JavaScript对象（即&#123;&#125;）；</span><br><span class="line">2、链接该对象（设置该对象的constructor）到另一个对象 ；</span><br><span class="line">3、将步骤1新创建的对象作为this的上下文 ；</span><br><span class="line">4、如果该函数没有返回对象，则返回this。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当代码 new Foo(...) 执行时，会发生以下事情：</span></span><br><span class="line"></span><br><span class="line">1、一个继承自 Foo.prototype 的新对象被创建。</span><br><span class="line">2、使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</span><br><span class="line">3、由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</span><br></pre></td></tr></table></figure></p>
<h3 id="原型继承与原型链"><a href="#原型继承与原型链" class="headerlink" title="原型继承与原型链"></a>原型继承与原型链</h3><p>有些人认为JavaScript并不是真正的面向对象语言，在经典的面向对象语言中，您可能倾向于定义类对象,然后您可以简单地定义哪些类继承哪些类，JavaScript使用了另一套实现方式，继承的对象函数并不是通过复制而来，而是通过原型链继承（在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的）</p>
<p><strong>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 `</strong>proto__<code>）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象(</code><strong>proto</strong>` ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。__</p>
<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。</p>
<p><strong>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</strong></p>
<p>Object.prototype 属性表示 Object 的原型对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原型链继承</span></span><br><span class="line"><span class="keyword">function</span> Person(first, last, age, gender, interests) &#123;</span><br><span class="line">  this.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.gender = gender;</span><br><span class="line">  this.interests = interests;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.greeting = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // <span class="keyword">do</span> something</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过call和apply继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Teacher(first, last, age, gender, interests, subject) &#123;</span><br><span class="line">  Person.call(this, first, last, age, gender, interests);</span><br><span class="line"></span><br><span class="line">  this.subject = subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>注：每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。当我们输入类似var person1=new Person(…)来构造对象时，JavaScript实际上参考的是Person.prototype指向的对象来生成person1。另一方面，Person()函数是Person.prototype的构造函数，也就是说Person===Person.prototype.constructor（不信的话可以试试）。在定义新的构造函数Teacher时，我们通过function.call来调用父类的构造函数，但是这样无法自动指定Teacher.prototype的值，这样Teacher.prototype就只能包含在构造函数里构造的属性，而没有方法。因此我们利用Object.create()方法将Person.prototype作为Teacher.prototype的原型对象，并改变其构造器指向，使之与Teacher关联。</strong></p>
<p> <strong><font color="red">*</font> 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</strong></p>
<h3 id="Object-create-和-Object-assign"><a href="#Object-create-和-Object-assign" class="headerlink" title="Object.create 和 Object.assign"></a>Object.create 和 Object.assign</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__（原型对象）。新对象的原型就是调用 create 方法时传入的第一个参数：</span></span><br><span class="line">var a = &#123;a: 1&#125;;</span><br><span class="line">// a ---&gt; Object.prototype ---&gt; null</span><br><span class="line"></span><br><span class="line">var b = Object.create(a);</span><br><span class="line">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span><br><span class="line">console.log(b.a); // 1 (继承而来)</span><br></pre></td></tr></table></figure>
<h3 id="工厂函数和类"><a href="#工厂函数和类" class="headerlink" title="工厂函数和类"></a>工厂函数和类</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h3><h3 id="纯函数-函数副作用和状态变化"><a href="#纯函数-函数副作用和状态变化" class="headerlink" title="纯函数, 函数副作用和状态变化"></a>纯函数, 函数副作用和状态变化</h3><h3 id="耗性能操作和时间复杂度"><a href="#耗性能操作和时间复杂度" class="headerlink" title="耗性能操作和时间复杂度"></a>耗性能操作和时间复杂度</h3><h3 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h3><h3 id="二进制-十进制-十六进制-科学记数法"><a href="#二进制-十进制-十六进制-科学记数法" class="headerlink" title="二进制, 十进制, 十六进制, 科学记数法"></a>二进制, 十进制, 十六进制, 科学记数法</h3><h3 id="偏函数-柯里化-Compose-和-Pipe"><a href="#偏函数-柯里化-Compose-和-Pipe" class="headerlink" title="偏函数, 柯里化, Compose 和 Pipe"></a>偏函数, 柯里化, Compose 和 Pipe</h3><h3 id="代码整洁之道"><a href="#代码整洁之道" class="headerlink" title="代码整洁之道"></a>代码整洁之道</h3><h3 id="promise执行顺序"><a href="#promise执行顺序" class="headerlink" title="promise执行顺序"></a>promise执行顺序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 500)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    resolve(3)</span><br><span class="line">&#125;).<span class="keyword">then</span>(res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    <span class="built_in">return</span> 4</span><br><span class="line">&#125;).<span class="keyword">then</span>(res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    resolve(5)</span><br><span class="line">&#125;).<span class="keyword">then</span>(res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    <span class="built_in">return</span> 6</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Sir_Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gofugui.github.io/2021/04/08/前端基础概念/">https://gofugui.github.io/2021/04/08/前端基础概念/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gofugui.github.io">Coding Your Life</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/Web/">Web</a><a class="post-meta__tags" href="/tags/ES6/">ES6</a><a class="post-meta__tags" href="/tags/html/">html</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/08/05/微信小程序使用canvas创建像素头像/"><i class="fa fa-chevron-left">  </i><span>微信小程序使用canvas创建像素头像</span></a></div><div class="next-post pull-right"><a href="/2021/03/30/中高级前端须注意的40条移动端H5坑位指南/"><span>中高级前端须注意的40条移动端H5坑位指南</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(chrome-extension://pkfjcehoipcdbiilobhcblbkmelocaka/start/skin/images/bg-51.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By Sir_Liu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>