<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="最长递增子序列算法"><meta name="keywords" content="动态规划"><meta name="author" content="Sir_Liu"><meta name="copyright" content="Sir_Liu"><title>最长递增子序列算法 | Coding Your Life</title><link rel="shortcut icon" href="/vite.svg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Site Name Atom Feed"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4583227810964573" crossorigin="anonymous"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '3.9.0'
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、问题定义"><span class="toc-number">1.</span> <span class="toc-text">一、问题定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、动态规划解法（基础）"><span class="toc-number">2.</span> <span class="toc-text">二、动态规划解法（基础）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心思路"><span class="toc-number">2.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现"><span class="toc-number">2.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析"><span class="toc-number">2.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、贪心-二分查找（优化解法）"><span class="toc-number">3.</span> <span class="toc-text">三、贪心 + 二分查找（优化解法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心思路-1"><span class="toc-number">3.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码实现-1"><span class="toc-number">3.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复杂度分析-1"><span class="toc-number">3.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、关键差异对比"><span class="toc-number">4.</span> <span class="toc-text">四、关键差异对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、总结"><span class="toc-number">5.</span> <span class="toc-text">五、总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/mirror-assets/16d2a30b4d8e2a895e6~tplv-t2oaga2asx-jj-mark:72:72:0:0:q75.avis"></div><div class="author-info__name text-center">Sir_Liu</div><div class="author-info__description text-center">无论从事什么行业，只要做好两件事就够了，一个是你的专业、一个是你的人品，专业决定了你的存在，人品决定了你的人脉，剩下的就是坚持，用善良專業和真诚赢取更多的信任。（No matter what industry you are in, it is enough to do two things well, one is your profession and the other is your character. Your profession determines your existence, and your character determines your network. The rest is persistence, and you should win more trust with kindness, professionalism and sincerity.）</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">16</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(chrome-extension://pkfjcehoipcdbiilobhcblbkmelocaka/start/skin/images/bg-51.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coding Your Life</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/atom.xml">rss</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">最长递增子序列算法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2025-05-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/算法/">算法</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1k</span><span class="post-meta__separator">|</span><span>阅读时长: 4 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>最长递增子序列（Longest Increasing Subsequence，LIS）是一个经典的动态规划问题，目标是在给定数组中找到一个最长的严格递增子序列（元素可以不连续）。以下从算法原理到优化实现进行详细解析：</p>
<h3 id="一、问题定义"><a href="#一、问题定义" class="headerlink" title="一、问题定义"></a><strong>一、问题定义</strong></h3><p>给定一个无序的整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，长度为4。</span><br></pre></td></tr></table></figure></p>
<h3 id="二、动态规划解法（基础）"><a href="#二、动态规划解法（基础）" class="headerlink" title="二、动态规划解法（基础）"></a><strong>二、动态规划解法（基础）</strong></h3><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h4><ul>
<li><strong>状态定义</strong>：<code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长递增子序列的长度。</li>
<li><strong>状态转移</strong>：对于每个 <code>i</code>，遍历其前面的所有元素 <code>j</code>（<code>0 ≤ j &lt; i</code>），如果 <code>nums[j] &lt; nums[i]</code>，则 <code>dp[i] = max(dp[i], dp[j] + 1)</code>。</li>
<li><strong>初始状态</strong>：每个元素自身构成一个长度为1的子序列，故 <code>dp[i] = 1</code>。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长递增子序列暴力算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthOfLIS</span>(<span class="params">nums: number[]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="built_in">Array</span>(len).fill(<span class="number">1</span>)  <span class="comment">// 初始化dp数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp)  <span class="comment">// 返回最大值</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 但是上面的算法子能获取最长递增子序列的长度，但是不能返回最长递增子序列。下面改造一下：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthOfLIS</span>(<span class="params">nums: number[]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="built_in">Array</span>(len).fill(<span class="number">1</span>)  <span class="comment">// 初始化dp数组</span></span><br><span class="line">    <span class="keyword">const</span> preNode = <span class="built_in">Array</span>(len).fill(<span class="number">-1</span>);    <span class="comment">// 记录每个位置的递增子序列的前一个节点</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">1</span>, lastIndex = <span class="number">0</span>;  <span class="comment">// 最长递增子序列的长度，以及最长递增子序列的最后一个节点的索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i] &amp;&amp; dp[i] &lt;= dp[j] + <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                preNode[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt; maxLen)&#123;</span><br><span class="line">            maxLen = dp[i];</span><br><span class="line">            lastIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res: number[] = [];</span><br><span class="line">    <span class="keyword">while</span>(lastIndex !== <span class="number">-1</span>)&#123;</span><br><span class="line">        res.push(nums[lastIndex]);</span><br><span class="line">        lastIndex = preNode[lastIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse();  <span class="comment">// 返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><ul>
<li><strong>时间复杂度</strong>：$O(n^2)$，需要两层循环。</li>
<li><strong>空间复杂度</strong>：$O(n)$，用于存储 <code>dp</code> 数组。</li>
</ul>
<h3 id="三、贪心-二分查找（优化解法）"><a href="#三、贪心-二分查找（优化解法）" class="headerlink" title="三、贪心 + 二分查找（优化解法）"></a><strong>三、贪心 + 二分查找（优化解法）</strong></h3><h4 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h4><ul>
<li><strong>维护一个数组 <code>tails</code></strong>：其中 <code>tails[k]</code> 表示长度为 <code>k+1</code> 的递增子序列的末尾最小元素。</li>
<li><strong>遍历数组</strong>：对于每个元素 <code>num</code>，通过二分查找找到其在 <code>tails</code> 中的插入位置：<ul>
<li>如果 <code>num</code> 大于所有 <code>tails</code> 中的元素，直接添加到末尾，形成更长的子序列。</li>
<li>否则，替换第一个大于等于 <code>num</code> 的元素，保持 <code>tails</code> 的最小性。</li>
</ul>
</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthOfLIS</span>(<span class="params">nums: number[]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> tails: number[] = []  <span class="comment">// 维护当前最长递增子序列的末尾元素</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">let</span> right = tails.length;</span><br><span class="line">        <span class="comment">// 二分查找插入位置, 找到第一个大于等于nums[i]的索引</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 中间位置索引</span></span><br><span class="line">            <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span>(tails[mid] &lt; nums[i])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入或替换元素</span></span><br><span class="line">        <span class="keyword">if</span> (left == tails.length)</span><br><span class="line">            tails.push(nums[i])  <span class="comment">// 形成更长的子序列</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tails[left] = nums[i]  <span class="comment">// 替换为更小的末尾元素</span></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> tails.length  <span class="comment">// tails的长度即为LIS长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><ul>
<li><strong>时间复杂度</strong>：$O(n \log n)$，每次二分查找耗时 $O(\log n)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$，主要用于存储 <code>tails</code> 数组。</li>
</ul>
<h3 id="四、关键差异对比"><a href="#四、关键差异对比" class="headerlink" title="四、关键差异对比"></a><strong>四、关键差异对比</strong></h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>时间复杂度</strong></th>
<th><strong>空间复杂度</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>动态规划</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>数据规模较小（n ≤ 1000）</td>
</tr>
<tr>
<td>贪心 + 二分查找</td>
<td>$O(n \log n)$</td>
<td>$O(n)$</td>
<td>数据规模较大（n &gt; 1000）</td>
</tr>
</tbody>
</table>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><ul>
<li><strong>动态规划</strong>：适用于小规模数据，代码简单易理解。</li>
<li><strong>贪心 + 二分查找</strong>：适用于大规模数据，性能更优，但逻辑较复杂。</li>
<li><strong>应用场景</strong>：涉及最长递增子序列的问题（如版本控制、序列比对等）。</li>
</ul>
<p>掌握这两种解法，能应对大多数 LIS 相关问题，并可根据数据规模选择最优方案。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Sir_Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gofugui.github.io/2025/05/27/最长递增子序列算法/">https://gofugui.github.io/2025/05/27/最长递增子序列算法/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gofugui.github.io">Coding Your Life</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/动态规划/">动态规划</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2025/05/27/webpack5模块联邦技术/"><span>webpack5 模块联邦技术</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'Ov23liqBpY9MxdjqDFTA',
  clientSecret: 'c824e3fe864528851e7734e9f4661a8fd108b390',
  repo: 'gofugui.github.io',
  owner: 'gofugui',
  admin: 'gofugui',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4583227810964573" data-ad-slot="8925032663" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});
</script><footer class="footer-bg" style="background-image: url(chrome-extension://pkfjcehoipcdbiilobhcblbkmelocaka/start/skin/images/bg-51.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By Sir_Liu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script> <script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>